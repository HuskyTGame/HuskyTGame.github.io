---
layout: article
title:  "UGUI--基础_基础组件"
categories: unity
image:
    teaser: /in-post/unity/2019-09-30-UGUI--基础_基础组件/DefaultImg.jpg
---

# 目录

[TOC]

## 一、基础

### 1.适配小技巧--1_Pivot的应用

***Pivot：***

- **名称：**轴心点，
- **说明：**代表当前物体位置，是一个比例值。
- **使用：**在Inspector面板中可以直接修改；或者，更改"Center"为"Pivot"，如下图：

![picture0](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot000.png)

**例子：**想要中间的黑色Image适配到蓝色Image的左上角。

![picture1](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot001.png)

**方法一：**不使用Pivot

直接设置锚点，设置锚点的时候按住***"Alt"***键可以在设置锚点的同时设置物体Position。

设置之后的结果如下图：

![picture2](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot002.png)

黑色Image的Inspector面板显示如下图：

![picture3](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot003.png)

其中PosX和PosY分别为Width和Height的一半。

**此法的缺点：**在设置此Img的位置时候，代码中需要考虑到Img的宽高。

**方法二：**使用Pivot

首先将轴心点Pivot移动到左上角，然后同上一样设置锚点。

![picture4](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot004.png)

设置之后的结果如下图：

![picture5](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot005.png)

黑色Image的Inspector面板显示如下图：

![picture6](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot006.png)

此时的PosX和PosY均为0，意思是代表黑色Img位置的轴心点Pivot与锚点之间的相对位置为(0,0)。

**此法的优点：**不再需要在代码中考虑Img的宽高，降低代码复杂度。

### 2.获取UI宽高（安全方式）

````csharp
//获取RectTransform
RectTransform rectTrans = transform.GetComponent<RectTransform>();
//通过RectTransform获取宽高：
rectTrans.rect.width;
rectTrans.rect.height;
````

### 3.使用蓝图模式控制UI旋转、缩放时的响应区域

**蓝图模式**

**开启方式：**在检视面板中，如下图所示：

![picture7](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot007.png)

**作用：**开启后，无论是旋转还是缩放UI，UI的响应区域均保持不变。

![picture8](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot008.png)

**使用情景：**UI存在动画，但即使是在动画播放的过程中依旧需要保持响应区域不变，则可以使用蓝图模式。

### 4.原始编辑模式(Raw Edit Mode)

**原始编辑模式**

**开启方式：**在检视面板中，如下图所示：

![picture9](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot009.png)

**作用：**作用于Anchors和Pivot，具体应用场景不详。

### 5.Canvas的三种模式

![picture10](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot010.png)

- 1.**Screen Space - Overlay：**

![picture11](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot011.png)

a.画布独立于场景空间存在，存在于屏幕空间；b.UI永远显示在最上层；c.画布的坐标计算基于屏幕空间，由Unity自动计算，不可在检视面板中手动调整。

Pixel Perfect：开启后，会关闭抗锯齿，抗锯齿会影响到像素，所以在像素要求严格的情况下勾选。

Sort order：排序

- 2.**Screen Space - Camera：**

![picture12](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot012.png)

a.画布需要与指定相机关联（Render Camera）；b.画布的坐标计算基于屏幕空间，由Unity自动计算，不可在检视面板中手动调整。

关联后：

![picture13](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot013.png)

Plane Distance：画布平面到摄像机的距离，此距离即画布深度，会影响到UI是否被游戏物体遮挡（深度剔除）。

- 3.**World Space：**

同上也需要关联相机，关联后：

![picture14](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot014.png)

a.画布需要与指定相机关联（Render Camera）；b.画布的坐标计算基于世界空间，可在检视面板中手动调整。

### 6.三种不同UI Scale Mode下的适配

![picture15](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot015.png)

#### （1）Constant Pixel Size模式

![picture16](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot016.png)

Constant Pixel Size模式为恒定像素大小模式，屏幕中UI元素的大小由*ScaleFactor*(缩放因子)和*ReferencePixelsPerUnit*(每Unity单位对应的像素个数)共同决定。

在此模式下需要通过脚本来动态调整ScaleFactor：脚本挂载在Canvas中

````csharp
    public class ConstantScaler : MonoBehaviour
    {
        private const float SCREEN_WIDTH = 1334.0f;
        private const float SCREEN_HEIGHT = 750.0f;
        private void Start()
        {
            float wScreen = Screen.width / SCREEN_WIDTH;
            float hScreen = Screen.height / SCREEN_HEIGHT;
            //假定依据宽来适配：
            GetComponent<CanvasScaler>().scaleFactor = wScreen;
        }
    }
````

开发过程中，使用1334x750的Screen，如下图：

![picture17](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot017.png)

在真机运行时可能为其他分辨率，例如800x600或1920x1080等。

在编辑模式下，切换Screen为1920x1080后，如下图：

![picture18](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot018.png)

此时可以看见，并未适配成功，原因在于我们必须在运行模式下，执行Start方法中的逻辑才能调整scaleFactor。点击运行后，如下图：

![picture19](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot019.png)

此时的Canvas中的Canvas Scaler组件：

![picture20](https://huskytgame.github.io/images/in-post/unity/2019-09-30-UGUI--基础_基础组件/ScreenShot020.png)

Scale Factor由1变为了1.43928(≈1920/1334)，如此一来便达到了适配的效果。