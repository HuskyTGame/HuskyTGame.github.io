---
layout: article
title:  "UGUI--进阶_常规案例_上"
categories: unity
image:
    teaser: /in-post/unity/2019-11-24-UGUI--进阶_常规案例_上/DefaultImg.jpg
---

# 目录

[TOC]

## 一、UI遮挡3D物体响应

### 1.UI元素在3D物体之上时，只响应UI元素

![picture0](https://huskytgame.github.io/images/in-post/unity/2019-11-24-UGUI--进阶_常规案例_上/ScreenShot000.png)

- Step1：在**MainCamera**上添加***Physics Raycaster***物理射线组件
- Step2：3D物体的点击实现方式同UI元素一样：实现点击接口``IPointerClickHandler``

代码：

````csharp
    public class ClickThreeD : MonoBehaviour, IPointerClickHandler
    {
        private int mIndex;
        private void Start()
        {
            mIndex = 0;
        }
        public void OnPointerClick(PointerEventData eventData)
        {
            ChangeColor();
        }
        private void ChangeColor()
        {
            if (mIndex == 0)
            {
                GetComponent<MeshRenderer>().material.SetColor("_Color", Color.white);
            }
            else
            {
                GetComponent<MeshRenderer>().material.SetColor("_Color", Color.black);
            }
            mIndex = mIndex == 0 ? 1 : 0;
        }
    }
````

### 2.UI元素在3D物体之上时，同时响应UI元素和3D物体

延续1中的方法，只需要在响应UI元素时增加对3D物体的响应即可。

注意：

- UI元素（继承自``Graphic``）接收``Graphic Raycaster``图形射线的检测。
- 3D物体接收``Physics Raycaster``物理射线的检测。
- ``EventSystem.current.RaycastAll(...)``会获取上述所有的射线。

修改后的UI元素的代码

````csharp
    public class ClickUI : MonoBehaviour, IPointerClickHandler
    {
        private int mIndex;
        private void Start()
        {
            mIndex = 0;
        }
        public void OnPointerClick(PointerEventData eventData)
        {
            ChangeColor();
            //获取除当前UI元素以外的所有接受到射线检测的物体（包括图形射线、物理射线）
            //执行物体身上的点击事件pointerClickHandler
            ExecuteAll(eventData, ExecuteEvents.pointerClickHandler);
        }
        private void ExecuteAll<T>(PointerEventData eventData, ExecuteEvents.EventFunction<T> eventFunction)
            where T : IEventSystemHandler
        {
            //获取所有射线（包括图形射线、物理射线）
            List<RaycastResult> results = new List<RaycastResult>();
            EventSystem.current.RaycastAll(eventData, results);
            for (int i = 0; i < results.Count; i++)
            {
                if (results[i].gameObject != gameObject)//获取非当前物体
                {
                    //执行指定的事件eventFunction
                    ExecuteEvents.Execute(results[i].gameObject, eventData, eventFunction);
                }
            }
        }
        private void ChangeColor()
        {
            var img = GetComponent<Image>();
            if (mIndex == 0)
            {
                img.color = Color.red;
            }
            else
            {
                img.color = Color.blue;
            }
            mIndex = mIndex == 0 ? 1 : 0;
        }
    }
````

### 3.判断鼠标是否点击在UI上

UI元素接收``Graphic Raycaster``图形射线检测。

````csharp
    public class MouseClick : MonoBehaviour
    {
        private GraphicRaycaster mGraphicRaycaster;
        private void Start()
        {
            mGraphicRaycaster = FindObjectOfType<GraphicRaycaster>();
        }
        private bool IsUI()
        {
            //创建当前鼠标点击位置的点击事件参数PointerEventData
            PointerEventData eventData = new PointerEventData(EventSystem
                .current)
            {
                //pressPosition = Input.mousePosition,
                position = Input.mousePosition,
            };
            //获取图形射线响应的射线结果
            List<RaycastResult> results = new List<RaycastResult>();
            mGraphicRaycaster.Raycast(eventData, results);
            //存在图形射线响应的结果说明点击位置存在UI元素
            return results.Count > 0;
        }
    }
````

## 二、用顶点描绘圆形图片--制作技能图标（精确点击响应）

技能图标一般为圆形，UGUI没有现成的圆形*Image*组件来制作技能图标。所以做圆形技能图标需要用到*Mask*组件，使用圆形图片作为遮罩，但使用*Mask*组件会带来很大的性能开销，增加2个***Draw Call***。为了避免使用*Mask*组件，所以可以自己制作一个圆形Image组件。

圆形可以看做是由多个三角形组合而成，为此可以设置参数``mSegements``（圆分割的份数）

为了制作技能CD效果，需要记录技能CD的时间百分比，用圆形中小三角形填充的百分比代替``mFillPercent``。技能CD状态图标为灰色，可以定义CD状态图标颜色：``private readonly Color32 Gray = new Color32(60, 60, 60, 255);``。

制作圆形*Image*步骤如下：

- Step1：创建脚本并继承自***Image***，重写***Image***自带的方法``OnPopulateMesh``（填充网格）
- Step2：清空``VertexHelper``
- Step3：向``VertexHelper``中添加顶点（注意消除移动轴心点***pivot***所带来的顶点坐标的差异）
- Step4：向``VertexHelper``中添加三角形

此时已经有了一个圆形的可以表现技能CD效果的*Image*组件，接着需要处理图标精确点击的问题。

**精确点击算法**原理：**判断一点是否在图形内部**，方法：以该点为起点向某一方向引出一条射线，射线与图形边界***交点若为奇数=>点在内部***。

代码：

````csharp
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Sprites;
using UnityEngine.UI;

namespace StudyUGUIExample
{
    public class CircleImage : Image
    {
        #region Config
        private readonly Color32 Gray = new Color32(60, 60, 60, 255);
        #endregion

        /// <summary>
        /// 填充百分比
        /// </summary>
        [SerializeField]
        private float mFillPercent = default;
        /// <summary>
        /// 圆分割的份数
        /// </summary>
        [SerializeField]
        private int mSegements = default;

        private List<Vector3> mVertexList;

        /// <summary>
        /// 使用顶点填充网格
        /// </summary>
        /// <param 待填充的="toFill"></param>
        protected override void OnPopulateMesh(VertexHelper toFill)
        {
            toFill.Clear();
            AddVertex(toFill);
            AddTriangle(toFill);
        }
        private void AddVertex(VertexHelper toFill)
        {
            //当前的小三角形份数
            mVertexList = new List<Vector3>();
            int currentSegements = (int)(mFillPercent * mSegements);
            float width = GetComponent<RectTransform>().rect.width;
            float height = GetComponent<RectTransform>().rect.height;
            float radius = width * 0.5f;//圆半径
            float radian = 2f * Mathf.PI / mSegements;//每一块的弧度
            Vector4 uv = overrideSprite != null ? DataUtility.GetOuterUV(overrideSprite) : Vector4.zero;
            float uvWidth = uv.z - uv.x;
            float uvHeight = uv.w - uv.y;
            //转换系数=uv/实际宽高
            Vector2 convertRatio = new Vector2(uvWidth / width, uvHeight / height);
            Vector2 uvCenter = new Vector2(0.5f * (uv.x + uv.z), 0.5f * (uv.y + uv.w));
            //Vector2 uvCenter = new Vector2(0.5f * uvWidth, 0.5f * uvHeight);
            //圆心
            UIVertex origin = new UIVertex();
            origin.color = GetColorFromFillPercent(Gray, mFillPercent);
            origin.position = new Vector3((0.5f - rectTransform.pivot.x) * width, (0.5f - rectTransform.pivot.y) * height);//图形中心不随轴心点改变
            origin.uv0 = new Vector2(uvCenter.x, uvCenter.y);
            toFill.AddVert(origin);//添加顶点--圆心
            //添加顶点--圆周
            for (int i = 1; i <= mSegements + 1; i++)
            {
                float x = Mathf.Cos(radian * (i - 1)) * radius;
                float y = Mathf.Sin(radian * (i - 1)) * radius;
                UIVertex temp = new UIVertex();
                if (i <= currentSegements || mFillPercent >= 1f)
                {
                    temp.color = color;
                }
                else
                {
                    temp.color = Gray;
                }
                temp.position = new Vector3(x + (0.5f - rectTransform.pivot.x) * width, y + (0.5f - rectTransform.pivot.y) * height);
                temp.uv0 = new Vector2(x * convertRatio.x + uvCenter.x, y * convertRatio.y + uvCenter.y);
                toFill.AddVert(temp);
                mVertexList.Add(temp.position);
            }
        }
        private void AddTriangle(VertexHelper toFill)
        {
            //添加三角形
            for (int i = 1; i <= mSegements; i++)
            {
                toFill.AddTriangle(i, 0, i + 1);
            }
        }
        private Color32 GetColorFromFillPercent(Color32 filledColor, float fillPercent)
        {
            return new Color32
            {
                r = (byte)(filledColor.r + (255 - filledColor.r) * fillPercent),
                g = (byte)(filledColor.g + (255 - filledColor.g) * fillPercent),
                b = (byte)(filledColor.b + (255 - filledColor.b) * fillPercent),
                a = 255,
            };
        }

        #region 精确点击判断
        /*
         * 原理：判断一点是否在图形内部
         * 以该点为起点向某一方向引出一条射线，射线与图形边界交点若为奇数=>点在内部。
         */
        public override bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)
        {
            Vector2 pos;
            RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPoint, eventCamera, out pos);
            return IsValid(pos, mVertexList);
        }
        private bool IsValid(Vector3 pos, List<Vector3> vertexList)
        {
            return GetCrossPointNum(pos, vertexList) % 2 == 1;//交点为奇数则pos在内部
        }
        private int GetCrossPointNum(Vector3 pos, List<Vector3> vertexList)
        {
            int count = 0;
            for (int i = 0; i < vertexList.Count; i++)
            {
                Vector3 vertex1 = vertexList[i];
                Vector3 vertex2 = vertexList[(i + 1) % vertexList.Count];
                if ((pos.y < vertex2.y && pos.y > vertex1.y) || (pos.y > vertex2.y && pos.y < vertex1.y))
                {
                    if (GetX(vertex1, vertex2, pos.y) > pos.x) count++;
                }
            }
            return count;
        }
        private float GetX(Vector3 vertex1, Vector3 vertex2, float y)
        {
            //获取两顶点连线上的一点
            return (y - vertex1.y) * (vertex2.x - vertex1.x) / (vertex2.y - vertex1.y) + vertex1.x;
        }
        #endregion
    }
}
````

为了编辑方便，为该组件创建编辑扩展脚本：

````csharp
using UnityEngine;
using UnityEditor;
using UnityEditor.UI;

namespace StudyUGUIExample
{
    [CustomEditor(typeof(CircleImage), true), CanEditMultipleObjects]
    public class CircleImageEditor : ImageEditor
    {
        private SerializedProperty mFillPercent;//填充百分比
        private SerializedProperty mSegements;//圆分割的份数

        protected override void OnEnable()
        {
            base.OnEnable();
            mFillPercent = serializedObject.FindProperty("mFillPercent");
            mSegements = serializedObject.FindProperty("mSegements");
        }

        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            //更新序列化物体
            serializedObject.Update();

            EditorGUILayout.Slider(mFillPercent, 0f, 1f, new GUIContent("显示百分比"));
            EditorGUILayout.PropertyField(mSegements, new GUIContent("圆分割的份数"));
            //应用更改
            serializedObject.ApplyModifiedProperties();
            if (GUI.changed)
            {
                EditorUtility.SetDirty(target);
            }
        }
    }
}
````

自定义的圆形*Image*组件编辑界面如下图：

![picture1](https://huskytgame.github.io/images/in-post/unity/2019-11-24-UGUI--进阶_常规案例_上/ScreenShot001.png)

测试效果：任意多边形+CD效果+精确点击

![GIF1](https://huskytgame.github.io/images/in-post/unity/2019-11-24-UGUI--进阶_常规案例_上/CustomCircleImageAnim.gif)

后续还可进行更多扩展，此处略。

## 三、UGUI不规则响应区域





## 四、使用2D*Image*制作仿3D轮转图

## 五、雷达图

## 六、优化版滚动视图

## 七、血条

## 八、UGUI特效层级问题

## 九、裁切粒子特效

## 十、互动照片墙

## 十一、UGUI翻书效果

## 十二、炉石套牌界面

## 十三、图文混排

## 十四、多语言解决方案

## 十五、UGUI图表







