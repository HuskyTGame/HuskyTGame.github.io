---
layout: article
title:  "SRP--定制管线"
categories: shader
image:
    teaser: /in-post/shader/2019-10-05-SRP--定制管线/DefaultImg.jpg
---

# 目录

[TOC]

# 一、创建管道

## 1.项目设置

在***"Edit--Project Settings--Player--Other Settings--Rendering--Color Space"***中设置颜色空间为线性空间（默认设置为Gamma空间）。

## 2.创建管道资产

### （1）添加创建管道资产的功能--编辑器扩展：

**使用的API：**

- " : RenderPipelineAsset"：

  该类需继承自"RenderPipelineAsset"才可创建渲染管线资产。

- "using UnityEngine.Experimental.Rendering;"：

  若要继承"RenderPipelineAsset"需引入"UnityEngine.Experimental.Rendering"命名空间。该空间在2018.3版中尚属实验性。

- "protected override IRenderPipeline InternalCreatePipeline()"：

  创建渲染管线。继承自"RenderPipelineAsset"后必须实现的方法，返回值为创建的渲染管线实例。渲染管线实例负责渲染过程。

- "[CreateAssetMenu(fileName = "My Pipeline", menuName = "Rendering/My Pipeline", order = 1)]"：

  特性，添加此特性后，在编辑模式中可以通过鼠标右键创建资产文件。

````csharp
using UnityEngine;
using UnityEngine.Experimental.Rendering;

namespace StudySRP
{
    [CreateAssetMenu(fileName = "My Pipeline", menuName = "Rendering/My Pipeline", order = 1)]
    public class MyPipelineAsset : RenderPipelineAsset
    {
        /// <summary>
        /// 创建管道
        /// </summary>
        /// <returns>渲染管线实例</returns>
        protected override IRenderPipeline InternalCreatePipeline()
        {
            return null;
        }
    }
}
````

### （2）创建管道资产：
"***鼠标右键--Create--Rendering--My Pipeline***"即可创建管道资产

![picture0](https://huskytgame.github.io/images/in-post/shader/2019-10-05-SRP--定制管线/ScreenShot000.png)

### （3）设置自定义管道资产：

将上述创建的管道资产拖拽到"Edit--Project Settings--Graphics--Scriptable Render Pipeline Settings"中。

![picture1](https://huskytgame.github.io/images/in-post/shader/2019-10-05-SRP--定制管线/ScreenShot001.png)

设置好了之后，场景和游戏视图都不再绘制任何内容，因为此时使用的是自定义的渲染管线，而自定义的渲染管线中暂时还什么都没有。

### （4）创建渲染管线实例：

创建管道资产后，还需要为管道资产创建一个渲染管线实例。渲染管线实例负责渲染过程，可以继承自"IRenderPipeline"接口，也可以直接继承自"RenderPipeline"（一个"IRenderPipeline"的基本实现）。

````csharp
using UnityEngine.Experimental.Rendering;

namespace StudySRP
{
    public class MyPipeline : RenderPipeline
    {

    }
}
````

在创建管道资产的方法中返回此渲染管线实例：

````csharp
using UnityEngine;
using UnityEngine.Experimental.Rendering;

namespace StudySRP
{
    [CreateAssetMenu(fileName = "My Pipeline", menuName = "Rendering/My Pipeline", order = 1)]
    public class MyPipelineAsset : RenderPipelineAsset
    {
        /// <summary>
        /// 创建管道
        /// </summary>
        /// <returns>渲染管线实例</returns>
        protected override IRenderPipeline InternalCreatePipeline()
        {
            return new MyPipeline();
        }
    }
}
````

## 3.自定义渲染管线的渲染流程

### （1）渲染上下文和摄像机

**使用的API：**

- "public override void Render(ScriptableRenderContext renderContext, Camera[] cameras)"：

  在自定义渲染管线脚本"MyPipeline"中重写渲染方法。其中"ScriptableRenderContext"为渲染上下文，使用渲染上下文可以向Unity发出指令（渲染事物/控制事物的渲染状态）；"Camera[]"为需要渲染的所有相机的数组。

  此函数不会绘制任何内容，但会检查渲染管线是否有效用于渲染，若无效，则会报一个异常。重写此方法，并调用基本实现，以保留此检查。

````csharp
        /// <summary>
        /// 此函数不会绘制任何内容，但会检查渲染管线是否有效用于渲染。
        /// 若无效，则会报一个异常。
        /// 覆盖此方法，并调用基本实现，以保留此检查。
        /// </summary>
        /// <param 渲染上下文="renderContext"></param>
        /// <param 需要渲染的所有相机的数组="cameras"></param>
        public override void Render(ScriptableRenderContext renderContext, Camera[] cameras)
        {
            base.Render(renderContext, cameras);
            //遍历执行每个摄像机的渲染
            for (int i = 0; i < cameras.Length; i++)
            {
                Render(renderContext, cameras[i]);
            }
        }
        /// <summary>
        /// 负责一个摄像机的渲染
        /// </summary>
        /// <param 渲染上下文="renderContext"></param>
        /// <param 需要渲染的摄像机="camera"></param>
        private void Render(ScriptableRenderContext context, Camera camera)
        {
            //使用渲染上下文可以向Unity发出指令（渲染事物/控制事物的渲染状态）
            //此指令被存放于渲染上下文的内部缓冲中，需提交后Unity才执行。
        }
    }
````

### （2）绘制天空盒

**使用的API：**

- "context.SetupCameraProperties(camera)"：

  设置好摄像机属性--VP矩阵，只有设置好VP矩阵才能正确绘制天空盒。

- "context.DrawSkybox(camera)"：

  向Unity发出绘制天空盒的指令，指令不会立即执行，会存放于渲染上下文的内部缓冲中，只有提交后才会真正执行此指令。

- "context.Submit()"：

  提交渲染上下文的内部缓冲中的指令。

````csharp
        /// <summary>
        /// 负责一个摄像机的渲染
        /// </summary>
        /// <param 渲染上下文="renderContext"></param>
        /// <param 需要渲染的摄像机="camera"></param>
        private void Render(ScriptableRenderContext context, Camera camera)
        {
            //使用渲染上下文可以向Unity发出指令（渲染事物/控制事物的渲染状态）
            //此指令被存放于渲染上下文的内部缓冲中，需提交后Unity才执行。

            //设置摄像机属性--VP矩阵
            context.SetupCameraProperties(camera);

            //1.绘制天空盒：
            context.DrawSkybox(camera);

            //提交渲染上下文的内部缓冲中的指令
            context.Submit();
        }
````

如果没有正确设置摄像机属性--VP矩阵，则天空盒不会被正确绘制，如下图所示：

![picture2](https://huskytgame.github.io/images/in-post/shader/2019-10-05-SRP--定制管线/ScreenShot002.png)

此时，查看Unity的帧调试，可以查看到错误的VP矩阵：

![picture3](https://huskytgame.github.io/images/in-post/shader/2019-10-05-SRP--定制管线/ScreenShot003.png)

  渲染上下文通过"SetupCameraProperties(camera)"正确设置摄像机属性--VP矩阵后，天空盒被正确绘制出来：

![picture4](https://huskytgame.github.io/images/in-post/shader/2019-10-05-SRP--定制管线/ScreenShot004.png)

此时，帧调试中显示了正确的VP矩阵：

![picture5](https://huskytgame.github.io/images/in-post/shader/2019-10-05-SRP--定制管线/ScreenShot005.png)

### （3）命令缓冲区

绘制命令需通过命令缓冲区提交到渲染上下文的内部缓冲区，然后执行。

**使用的API：**

- "CommandBuffer buffer = new CommandBuffer()"：

  构建命令缓冲对象。

- "CameraClearFlags clearFlags = camera.clearFlags"：

  获取指定摄像机的清除标志，如是否清除深度信息、颜色信息。

- "buffer.ClearRenderTarget(是否清除深度信息 , 是否清除颜色信息 , 背景颜色)"：

  命令缓冲区的命令--清除渲染目标。

- "context.ExecuteCommandBuffer(buffer)"：

  执行命令缓冲区的命令，此处不会立即执行，会先提交到渲染上下文的内部缓冲中

- "buffer.Release()"：

  释放命令缓冲，当将命令缓冲提交到渲染上下文的内部缓冲后，应立即释放命令缓冲。

````csharp
        /// <summary>
        /// 负责一个摄像机的渲染
        /// </summary>
        /// <param 渲染上下文="renderContext"></param>
        /// <param 需要渲染的摄像机="camera"></param>
        private void Render(ScriptableRenderContext context, Camera camera)
        {
		......
            //设置摄像机属性--VP矩阵
            context.SetupCameraProperties(camera);

            //命令缓冲区
            CommandBuffer buffer = new CommandBuffer
            {
                name = camera.name,//命令缓冲区的名字为摄像机的名字
            };
            //获取当前摄像机的清除标志
            //清除标志中每个"位"用于指示是否启用某个功能
            CameraClearFlags clearFlags = camera.clearFlags;
            //设置命令缓冲区中清除渲染目标的命令
            //第一个参数：是否清除深度信息
            //第二个参数：是否清除颜色信息
            //第三个参数：背景颜色
            //使用"位与"运算：前后相同则为1
            buffer.ClearRenderTarget
            (
                (clearFlags & CameraClearFlags.Depth) != 0,
                (clearFlags & CameraClearFlags.Color) != 0,
                camera.backgroundColor
            );
            //执行命令缓冲中的命令
            //不会立即执行，会先提交到渲染上下文的内部缓冲中
            context.ExecuteCommandBuffer(buffer);
            //释放命令缓冲
            buffer.Release();
		......
        }
````

在帧调试中可以看到执行的命令缓冲：清除了渲染目标，Z（深度缓冲区）和stencil（模板缓冲区）被清除。

注意：模板缓冲区不需要设置是否清除，因为它总是被清除。

![picture6](https://huskytgame.github.io/images/in-post/shader/2019-10-05-SRP--定制管线/ScreenShot006.png)

