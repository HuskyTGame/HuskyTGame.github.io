---
layout: article
title:  "OpenGL--1.入门"
categories: shader
image:
    teaser: /in-post/shader/2020-01-06-OpenGL--1.入门/DefaultImg.jpg
---

# 目录

[TOC]

# 一、写在前面

## 1.学习原因

想要完全掌握 Unity 中的 Shader 的代码编写，学习 OpenGL 将是必不可少的一步，此前已经有过 UnityShader 的学习经历，相信 OpenGL 的学习将不会太难。

## 2.学习资源

### （1）LearnOpenGL

教程出了很多内容了，作者还在更新，有完整中文译版。

难度适合入门

[LearnOpenGL（翻译）](https://learnopengl-cn.github.io/intro/)

[LearnOpenGL（原版）](https://learnopengl.com/)

[配套Code](<https://github.com/JoeyDeVries/LearnOpenGL>)

### （2）OpenGL-Tutorial

[OpenGL-Tutorial](http://www.opengl-tutorial.org/cn/beginners-tutorials/tutorial-1-opening-a-window/)

还在翻译中，有部分还是英文。

难度适合入门

### （3）OGLdev

[OGLdev](http://ogldev.atspace.co.uk/index.html)

[一步步学OpenGL3.3+](https://blog.csdn.net/cordova/category_9266966.html)

中文还在翻译中，超过一半课程有中文。

难度适合有过基础OpenGL学习的人

### （4）Learn Computer Graphics From Scratch!

[Learn Computer Graphics From Scratch!](https://www.scratchapixel.com/)

计算机图形学，全英文，适合进阶

## 3.环境配置前的简要说明

### （1）OpenGL

OpenGL 函数库相关的 API 有核心库(gl)，实用库(glu)，辅助库(aux)、实用工具库(glut)，窗口库(glx、agl、wgl)和扩展函数库等。

gl 是核心，glu 是对 gl 的部分封装。glx、agl、wgl 是针对不同窗口系统的函数。glut 是为跨平台的 OpenGL 程序的工具包，比aux功能强大（aux很大程度上已经被 glut 库取代。）。扩展函数库是硬件厂商为实现硬件更新利用OpenGL的扩展机制开发的函数。

### （2）GULT（OpenGL工具库--OpenGL Utility Toolkit）

这部分函数以 glut 开头。主要包括窗口操作函数，窗口初始化、窗口大小、窗口位置等函数；回调函数：响应刷新消息、键盘消息、鼠标消息、定时器函数等；创建复杂的三维物体；菜单函数；程序运行函数。gult 对应的开源实现是 freegult。

### （3）GLEW

GLUT 或者 FREEGLUT 主要是1.0的基本函数功能；GLEW 是使用 OPENGL2.0 之后的一个工具函数。

不同的显卡公司，也会发布一些只有自家显卡才支 持的扩展函数，你要想用这数涵数，不得不去寻找最新的 glext.h ,有了 GLEW 扩展库，你就再也不用为找不到函数的接口而烦恼，因为 GLEW 能自动识别你的平台所支持的全部 OpenGL 高级扩展函数。也就是说，只要包含一个 glew.h 头文件，你就能使用 gl , glu , glext , wgl , glx 的全部函数。

### （4）GLAD

GLAD 为 GLEW 升级版。

### （5）GLFW

GLFW 无愧于其号称的 lightweight 的 OpenGL 框架，的确是除了跨平台必要做的事情都没有做，所以一个头文件，很少量的 API，就完成了任务。GLFW 的开发目的是用于替代 glut 的，从代码和功能上来看，我想它已经完全的完成了任务。

一个轻量级的，开源的，跨平台的 library。支持 OpenGL 及 OpenGL ES，用来管理窗口，读取输入，处理事件等。因为 OpenGL 没有窗口管理的功能，所以很多热心的人写了工具来支持这些功能，比如早期的 glut，现在的 freeglut 等。

那么 GLFW 有何优势呢？glut 太老了，最后一个版本还是90年代的。freeglut 完全兼容 glut，算是 glut 的代替品，功能齐全，但是bug太多。稳定性也不好，GLFW 应运而生。

### （6）总结

- 1.OpenGL 只有框架没有实现，换句话说就是 OpenGL 只有函数声明没有实现，类似于接口和虚函数。所有的实现是显卡生产商提供。比如 NVIDIA (英伟达)就要自己实现 OpenGL 函数内容，所以不同的生产商可以对自己的产品提供优化，毕竟代码是自己写的。
- 2.glfw 是 glut 的升级和改进。glfw 是用来显示窗口和捕捉窗口事件的一套 API。OpenGL 只是一套控制 GPU 的规则，并没有对于跨平台窗口显示和事件进行规定，所以需要一个显示显卡渲染的窗口，这就是 glfw 的作用。
- 3.glew 包含了OpenGL所需的核心：<补充>第一条已经说过openGL的实现是显卡生产商，那么系统如何才能找到这些实现好的函数呢？而且不同的平台函数存放地方还不同，文件结构也不同。有没有一种方式能够自动找到 OpenGL 的函数？这就是 glew 的作用-->用来找 openGL 的函数，并初始化，这样我们就能直接调用 OpenGL 的函数了。
- 4.Glad 为 Glew 升级版。

## 4.环境配置

[参照此人的环境配置步骤](https://blog.csdn.net/AvatarForTest/article/details/79199807)

配置步骤详尽，亲测运行正常。

````c++
opengl32.lib
glfw3.lib

MSVCRT.lib
````

**VS为2017版**

[GLFW库下载官网](https://www.glfw.org/download.html)  下载的为**Source package**：**[glfw-3.3.1.zip](https://github.com/glfw/glfw/releases/download/3.3.1/glfw-3.3.1.zip)**

[GLEW库下载官网](https://www.glfw.org/download.html)  下载的为**ZIP**文件：**[Windows 32-bit and 64-bit](https://sourceforge.net/projects/glew/files/glew/2.1.0/glew-2.1.0-win32.zip/download)**

[GLAD库下载官网]()    下载地址、配置方法见环境配置

[CMake](https://cmake.org/download/)  下载为**[cmake-3.16.2-win64-x64.zip](https://github.com/Kitware/CMake/releases/download/v3.16.2/cmake-3.16.2-win64-x64.zip)**，用于编译**GLFW**库

# 二、

## 1.绘制渲染窗口

````c++
#include <iostream>
#include <glad/glad.h>
#include <GLFW/glfw3.h>

void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow* window);

int main()
{
	glfwInit();
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	//查看GLFW版本号：
	int major, minor, rev;
	glfwGetVersion(&major, &minor, &rev);
	printf("GLFW %d.%d.%d initialized\n", major, minor, rev);
	//创建 GLFW 窗口：
	GLFWwindow* window = glfwCreateWindow(800, 600, "LearnOpenGL", nullptr, nullptr);
	if (window == nullptr)
	{
		std::cout << "Failed to create GLFW window" << std::endl;
		glfwTerminate();//释放资源
		return -1;
	}
	glfwMakeContextCurrent(window);//将 window 注入当前主线程上下文
	//初始化 GLAD（用于管理 OpenGL 函数指针）：
	if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
	{
		std::cout << "Failed to initialize GLAD" << std::endl;
		glfwTerminate();//释放资源
		return -1;
	}
	//创建渲染窗口：（Viewport 视口）
	glViewport(0, 0, 800, 600);
	//注册回调：（Window 改变时改变 Viewport）
	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

	//渲染循环：（Render Loop）
	while (!glfwWindowShouldClose(window))
	{
		//清空颜色缓冲：
		glClearColor(0.0f, 0.34f, 0.57f, 1.0f);//设置清空屏幕的颜色值
		glClear(GL_COLOR_BUFFER_BIT);//清空颜色缓冲

		//输入：
		processInput(window);

		//渲染指令：

		//检查调用事件 并 交换颜色缓冲
		glfwPollEvents();//执行被触发的事件（键盘输入、鼠标移动、更新窗口状态、调用对应的回调函数）
		glfwSwapBuffers(window);//交换颜色缓冲
	}
	glfwTerminate();//释放资源
	return 0;
}

void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
	glViewport(0, 0, width, height);
}
void processInput(GLFWwindow* window)
{
	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
	{
		glfwSetWindowShouldClose(window, true);
	}
}
````



## 2.在窗口中绘制三角形

````c++
/***
 * 例程  绘制三角形 (MAKE后运行时可删除ALL_BUILD，也可以将Task-triangle设为默认启动工程)
 * 步骤:
 * 1-初始化:   GLFW窗口，GLAD。
 * 2-数据处理: 给定顶点数据，生成并绑定VAO&VBO(准备在GPU中进行处理)，设置顶点属性指针(本质上就是告诉OpenGL如何处理数据)。
 * 3-着色器:   给出顶点和片段着色器，然后链接为着色器程序，渲染时使用着色器程序。
 * 4-渲染:     清空缓冲，绑定纹理，使用着色器程序，绘制三角形，交换缓冲区检查触发事件后释放资源
 */

#include <iostream>
#include <glad/glad.h>
#include <GLFW/glfw3.h>

int screen_width = 1280;
int screen_height = 720;

void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow* window);

int main()
{
	//Step1：初始化 OpenGL
	//  初始化 GLFW：
	glfwInit();
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	int major, minor, rev;
	glfwGetVersion(&major, &minor, &rev);
	printf("GLFW %d.%d.%d initialized\n", major, minor, rev);
	//  创建 window：
	GLFWwindow* window = glfwCreateWindow(screen_width, screen_height, "Draw Triangle", nullptr, nullptr);
	if (window == nullptr)
	{
		std::cout << "Failed to create OpenGL contex" << std::endl;
		glfwTerminate();
		return -1;
	}
	glfwMakeContextCurrent(window);
	//  初始化 GLAD：（加载 OpenGL 函数指针地址的函数）
	if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
	{
		std::cout << "Failed to initialize GLAD" << std::endl;
		glfwTerminate();
		return -1;
	}
	std::cout << "GLAD initialize done" << std::endl;
	//  设置Viewport 尺寸：
	glViewport(0, 0, screen_width, screen_height);
	//  注册 framebuffer_size_callback 回调（Window 改变时改变 Viewport）
	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
	std::cout << "OpenGL initialize done" << std::endl;


	//Step2：顶点输入
	//  创建三角形顶点数据：
	const float triangle[] = {
		-0.5f,0.5f,0.0,
		0.5f,0.0f,0.0f,
		0.0f,-0.5f,0.0f
	};


	//Step3：数据处理
	//  生成并绑定 VBO：
	GLuint vertex_buffer_object;
	glGenBuffers(1, &vertex_buffer_object); //一个缓冲 ID 生成一个 VBO 对象
	glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer_object);
	//  将顶点数据绑定至当前默认的缓冲中：
	glBufferData(GL_ARRAY_BUFFER, sizeof(triangle), triangle, GL_STATIC_DRAW);
	//  生成并绑定 VAO：
	GLuint vertex_array_object;
	glGenVertexArrays(1, &vertex_array_object);
	glBindVertexArray(vertex_array_object);
	//  设置顶点属性指针：（向 OpenGL 解释顶点数据）
	//    参数1：顶点着色器的位置值
	//    参数2：顶点属性是一个三分量的向量
	//    参数3：顶点属性类型
	//    参数4：顶点数据是否需要标准化
	//    参数5：步长--连续顶点属性之间的间隔
	//    参数6：数据的偏移量（此处位置属性在数组的开头，所以是0）
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
	//  开启 0 的这个通道：
	glEnableVertexAttribArray(0);
	//  解绑 VAO 和 VBO：
	glBindVertexArray(0);
	glBindBuffer(GL_ARRAY_BUFFER, 0);


	//Step4：顶点着色器与片段着色器
	//  顶点着色器源码：
	const char* vertex_shader_source =
		"#version 330 core\n"
		"layout (location = 0) in vec3 aPos;\n"    //  location = 0，0 为位置变量的属性位置值
		"void main()\n"
		"{\n"
		"    gl_Position = vec4(aPos , 1.0);\n"
		"}\n\0";
	//  片段着色器源码：
	const char* fragment_shader_source =
		"#version 330 core\n"
		"out vec4 FragColor;\n"
		"void main()\n"
		"{\n"
		"    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"
		"}\n\0";


	//Step5：生成并编译着色器
	//  顶点着色器：
	int vertex_shader = glCreateShader(GL_VERTEX_SHADER);//创建
	glShaderSource(vertex_shader, 1, &vertex_shader_source, nullptr);//赋值
	glCompileShader(vertex_shader);//编译
	//  检查是否成功编译：
	int success;
	char info_log[512];
	glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);
	if (!success)
	{
		glGetShaderInfoLog(vertex_shader, 512, nullptr, info_log);
		std::cout << "ERROR::SHADER::VERTEX::COMPLATION_FAILED\n" << info_log << std::endl;
	}
	//  片段着色器：
	int fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);//创建
	glShaderSource(fragment_shader, 1, &fragment_shader_source, nullptr);//赋值
	glCompileShader(fragment_shader);//编译
	//  检查是否成功编译：
	glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);
	if (!success)
	{
		glGetShaderInfoLog(fragment_shader, 512, nullptr, info_log);
		std::cout << "ERROR::SHADER::FRAGMENT::COMPLATION_FAILED\n" << info_log << std::endl;
	}
	//  链接顶点、片段着色器至一个着色器程序：
	int shader_program = glCreateProgram();//创建
	glAttachShader(shader_program, vertex_shader);
	glAttachShader(shader_program, fragment_shader);
	glLinkProgram(shader_program);//链接
	//  检查是否链接成功：
	glGetProgramiv(shader_program, GL_LINK_STATUS, &success);
	if (!success)
	{
		glGetProgramInfoLog(shader_program, 512, nullptr, info_log);
		std::cout << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << info_log << std::endl;
	}
	//  删除着色器：
	glDeleteShader(vertex_shader);
	glDeleteShader(fragment_shader);


	//    线框模式：（绘制线条）
	//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);


	//Step6：渲染循环（Render Loop）
	while (!glfwWindowShouldClose(window))
	{
		//  清空颜色缓冲：
		glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
		glClear(GL_COLOR_BUFFER_BIT);
		//  输入：
		processInput(window);
		//  使用着色器程序：
		glUseProgram(shader_program);
		//  绘制三角形：
		glBindVertexArray(vertex_array_object);
		glDrawArrays(GL_TRIANGLES, 0, 3);
		glBindVertexArray(0);
		//  交换缓冲并检查是否有触发事件（鼠标、键盘输入等）
		glfwSwapBuffers(window);
		glfwPollEvents();
	}


	//Step7：收尾工作
	//  删除 VAO 和 VBO
	glDeleteVertexArrays(1, &vertex_array_object);
	glDeleteBuffers(1, &vertex_buffer_object);
	//  清理资源、退出程序
	glfwTerminate();
	return 0;
}

void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
	glViewport(0, 0, width, height);
}
void processInput(GLFWwindow* window)
{
	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
	{
		glfwSetWindowShouldClose(window, true);
	}
}
````















[Reference]

[LearnOpenGL](https://learnopengl-cn.github.io)

[OpenGL+VS2017 环境配置(亲测好使)<附带必要知识点>](https://blog.csdn.net/AvatarForTest/article/details/79199807)