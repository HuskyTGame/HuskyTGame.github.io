---
layout: article
title:  "计算机图形学--光栅图形学算法_基础"
categories: shader
image:
    teaser: /in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/DefaultImg.jpg
---

# 目录

[TOC]

# 一、写在前面

光栅图形学算法是计算机图形学的基础，本篇主要记录光栅图形学基础算法原理及实现，供以后快速复习使用。

# 二、直线段的扫描转换算法

## 1.数值微分法（DDA）

### （1）简介

DDA算法全称：Digital Differential Analyzer。

引进图形学中一个很重要的思想——增量思想。

### （2）原理

直线斜截式方程：
$$
y=kx+b
$$
上述方程中包含有乘法运算，可以通过简单变形来消去乘法运算：
$$
\begin{align}
y_{i+1}&=kx_{i+1}+b\\
&=k(x_i+1)+b\\
&=kx_i+b+k\\
&=y_i+k
\end{align}
$$

由于像素坐标为整数，而斜率 k 的值可能为小数，所以需要将计算结果增加 0.5 之后取整：``y = (int)(y + k + 0.5f)``

### （3）优缺点

优点：

- 1.引入了增量思想，将原本的乘法运算变为了增量加法运算，提升了算法效率。

缺点：

- 1.未考虑最大位移方向。在斜率 k 的值小于 1 的时候，该算法表现正常；当斜率 k 的值远大于 1 的时候，该算法画出来的直线像素点过于稀疏。
- 2.取整运算，影响算法效率。

### （4）实现

下面实现的为改进后的 DDA 算法，算法考虑了最大位移方向：

````c++
/*
	DDA：Digital Differential Analyzer 数值微分分析（线段扫描转换算法 / 增量算法）
	重点：寻找最大位移方向，在该方向上逐步得到各像素位置
*/
#include "DDA.h"
#include <math.h>
#include <GLFW/glfw3.h>

inline int DDA::round(const float n)
{
	return (int)(n + 0.5);
}
void DDA::LineDDA(int x0, int y0, int xend, int yend)
{
	int dx = xend - x0, dy = yend - y0, maxStep;
	float xIncrement, yIncrement, x = x0, y = y0;
	//  获取最大位移方向
	if (abs(dx) > abs(dy))
		maxStep = abs(dx);
	else
		maxStep = abs(dy);
	//  增量计算
	xIncrement = float(dx) / float(maxStep);
	yIncrement = float(dy) / float(maxStep);
	//  输出最佳逼近的像素点
	for (int i = 0; i <= maxStep; i++)
	{
		//putpixel(round(x), round(y));
		x += xIncrement;
		y += yIncrement;
	}
}
````

## 2.中点画线法

### （1）简介

中点画线法考虑了最大位移方向，同时消除了浮点运算。DDA 算法中采用的是直线的斜截式方程，而中点画线算法采用的是直线的一般方程。

### （2）原理

直线一般式：
$$
F(x,y)=Ax+By+C \qquad \text {A,B,C为整数}
$$

将中点 M 代入直线一般式中：

若结果小于 0 则说明中点 M 在直线下方，则应该选取中点 M 上方的点 Pu 作为直线上显示的像素点；（因为 Pu 距离直线较近）

若结果大于 0 则说明中点 M 在直线上方，则应该选取中点 M 下方的点 Pd 作为直线上显示的像素点。

- 1.当 F(M0) < 0 时，会选取 Pu 作为直线上显示的像素点，继 M0 之后的下一个中点即为 M1，如下图所示：

![picture0](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot000.png)

令 d = F(M)，则：
$$
\begin{align}
d&=F(x_i+1,y_i+0.5)\\
&=A(x_i+1)+B(y_i+0.5)+C
\end{align}
$$
当 d < 0 时，选取 Pu 点。同时可以递推计算下一个 d 的值：
$$
\begin{align}
d&=F(x_i+2,y_i+1.5)\\
&=A(x_i+2)+B(y_i+1.5)+C\\
&=F(x_i+1,y_i+0.5)+A+B\\
&=d+A+B
\end{align}
$$

- 2.当 F(M0) >= 0 时，会选取 Pd 作为直线上显示的像素点，继 M0 之后的下一个中点即为 M1，如下图所示：

![picture0](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot001.png)

当 d >= 0 时，选取 Pd 点。同时可以递推计算下一个 d 的值：
$$
\begin{align}
d&=F(x_i+2,y_i+0.5)\\
&=A(x_i+2)+B(y_i+0.5)+C\\
&=F(x_i+1,y_i+0.5)+A\\
&=d+A
\end{align}
$$

- 3.计算 d 的初始值：

$$
\begin{align}
d_0&=F(x_0+1,y_0+0.5)\\
&=A(x_0+1)+B(y_0+0.5)+C\\
&=F(x_0,y_0)+A+0.5B\\
&=A+0.5B
\end{align}
$$

- 4.综上：

$$
\left\{ 
\begin{align}
d_0&=A+0.5B\\
d&=d+A+B \qquad \text {d < 0}\\
d&=d+A \qquad \text {d >= 0}
\end{align}
\right.
$$

因为定义了A、B、C为整数，为了消除算法中的浮点运算，所以将A、B、C均乘 2。

如下式：
$$
\left\{ 
\begin{align}
d_0&=2A+B\\
d&=d+2A+2B \qquad \text {d < 0}\\
d&=d+2A \qquad \text {d >= 0}
\end{align}
\right.
$$

### （3）优缺点

优点：

- 1.考虑了最大位移方向（对 DDA 的改进）
- 2.消除了浮点运算（对 DDA 的改进）

缺点：

- 1.使用的方程是直线的一般式，算法的使用依赖于方程形式，不够通用。

## 3.Bresenham 算法

### （1）简介

Bresenham 发明的，经典图形学算法。结合了 DDA 和 中点画线法 的优点，不再依赖方程形式，具有通用性，不但可以绘制直线，还可以绘制圆、椭圆等曲线。

### （2）原理

下面只讨论 0 <= k <=1 时的情形。

使用直线斜截式。下图中的 k 即为直线斜率，每个格子边长为 1。

![picture0](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot002.png)

随着横坐标 x 依次递增，只需要判断纵坐标 y 是否加 1 即可。

如上图所示，记录一个值，记为 d，x 每增加 1，d 增加 k，当 d 超过 1 的时候取超过 1 的小数部分。

此时要判断 y 是否加 1，只需判断 d 值是否大于 0.5。若 d > 0.5，则 y 加 1；若 d <= 0.5，则 y 不变。

d 的初始值 d0 = 0。

综上：
$$
\begin{align}
d_0&=0\\
d&=d+k\\
x_{i+1}&=x_i+1\\
y_{i+1}&=y_i \qquad \text {d <= 0.5}\\
y_{i+1}&=y_i+1 \qquad \text {d > 0.5    d = d - 1}
\end{align}
$$
为了避免 d 与浮点数比较，令 e = d - 0.5：
$$
\begin{align}
e_0&=-0.5\\
e&=e+k\\
x_{i+1}&=x_i+1\\
y_{i+1}&=y_i \qquad \text {e <= 0}\\
y_{i+1}&=y_i+1 \qquad \text {e > 0    e = e - 1}
\end{align}
$$
因为斜率 k = delta(y) / delta(x)，为了避免浮点运算，将上式乘以 2 倍的 delta(x)：
$$
\begin{align}
e_0&=-\Delta{x}\\
e&=e+2\Delta{y}\\
x_{i+1}&=x_i+1\\
y_{i+1}&=y_i \qquad \text {e <= 0}\\
y_{i+1}&=y_i+1 \qquad \text {e > 0    e = e - 2delta(x)}
\end{align}
$$
其中 delta(y) 和 delta(x) 均为所绘制的直线的两个端点的坐标之差。

如此一来，便消除了所有的浮点运算。

### （3）优缺点

优点：

- 1.集合了 DDA 和 中点画线法 的优点。
- 2.直线的绘制不依赖于所使用的的方程形式，只需要知道直线两端点坐标即可。（对 中点画线法 的改进）

### （4）实现

下面只实现了 0 <= k <=1 时的情形：

````c++
#include "Bresenham.h"
#include <math.h>
//  0<=k<=1时：
void Bresenham::LineBrecenham(int x0, int y0, int xend, int yend)
{
	int e, dx = xend - x0, dy = yend - y0, x = x0, y = y0;
	e = -dx;
	while (x < xend)
	{
		e += 2 * dy;
		x++;
		if (e > 0)
		{
			y++;
			e -= 2 * dx;
		}
		//putpixel(round(x), round(y));
	}
}
````

### 4.总结

- DDA 算法：把效率提高到了每步只做一个加法
- 中点画线算法：进一步把效率提高到每步只做一个整数加法
- Bresenham 算法：提供了一个更一般的算法，该算法不仅有好的效率，而且有更广泛的适用范围。

# 三、多边形的扫描转换与区域填充算法

## 1.X 扫描线算法











## 2.改进的 X 扫描线算法









## 3.区域填充算法







# 四、裁剪算法











# 五、反走样算法









# 六、消隐算法







