---
layout: article
title:  "计算机图形学--光栅图形学算法_基础"
categories: shader
image:
    teaser: /in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/DefaultImg.jpg
---

# 目录

[TOC]

# 一、写在前面

光栅图形学算法是计算机图形学的基础，本篇主要记录光栅图形学基础算法原理及实现，供以后快速复习使用。

# 二、直线段的扫描转换算法

## 1.数值微分法（DDA）

### （1）简介

DDA算法全称：Digital Differential Analyzer。

引进图形学中一个很重要的思想——增量思想。

### （2）原理

直线斜截式方程：
$$
y=kx+b
$$
上述方程中包含有乘法运算，可以通过简单变形来消去乘法运算：
$$
\begin{align}
y_{i+1}&=kx_{i+1}+b\\
&=k(x_i+1)+b\\
&=kx_i+b+k\\
&=y_i+k
\end{align}
$$

由于像素坐标为整数，而斜率 k 的值可能为小数，所以需要将计算结果增加 0.5 之后取整：``y = (int)(y + k + 0.5f)``

### （3）优缺点

优点：

- 1.引入了增量思想，将原本的乘法运算变为了增量加法运算，提升了算法效率。

缺点：

- 1.未考虑最大位移方向。在斜率 k 的值小于 1 的时候，该算法表现正常；当斜率 k 的值远大于 1 的时候，该算法画出来的直线像素点过于稀疏。
- 2.取整运算，影响算法效率。

### （4）实现

下面实现的为改进后的 DDA 算法，算法考虑了最大位移方向：

````c++
/*
	DDA：Digital Differential Analyzer 数值微分分析（线段扫描转换算法 / 增量算法）
	重点：寻找最大位移方向，在该方向上逐步得到各像素位置
*/
#include "DDA.h"
#include <math.h>
#include <GLFW/glfw3.h>

inline int DDA::round(const float n)
{
	return (int)(n + 0.5);
}
void DDA::LineDDA(int x0, int y0, int xend, int yend)
{
	int dx = xend - x0, dy = yend - y0, maxStep;
	float xIncrement, yIncrement, x = x0, y = y0;
	//  获取最大位移方向
	if (abs(dx) > abs(dy))
		maxStep = abs(dx);
	else
		maxStep = abs(dy);
	//  增量计算
	xIncrement = float(dx) / float(maxStep);
	yIncrement = float(dy) / float(maxStep);
	//  输出最佳逼近的像素点
	for (int i = 0; i <= maxStep; i++)
	{
		//putpixel(round(x), round(y));
		x += xIncrement;
		y += yIncrement;
	}
}
````

## 2.中点画线法

### （1）简介

中点画线法考虑了最大位移方向，同时消除了浮点运算。DDA 算法中采用的是直线的斜截式方程，而中点画线算法采用的是直线的一般方程。

### （2）原理

直线一般式：
$$
F(x,y)=Ax+By+C \qquad \text {A,B,C为整数}
$$

将中点 M 代入直线一般式中：

若结果小于 0 则说明中点 M 在直线下方，则应该选取中点 M 上方的点 Pu 作为直线上显示的像素点；（因为 Pu 距离直线较近）

若结果大于 0 则说明中点 M 在直线上方，则应该选取中点 M 下方的点 Pd 作为直线上显示的像素点。

- 1.当 F(M0) < 0 时，会选取 Pu 作为直线上显示的像素点，继 M0 之后的下一个中点即为 M1，如下图所示：

![picture0](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot000.png)

令 d = F(M)，则：
$$
\begin{align}
d&=F(x_i+1,y_i+0.5)\\
&=A(x_i+1)+B(y_i+0.5)+C
\end{align}
$$
当 d < 0 时，选取 Pu 点。同时可以递推计算下一个 d 的值：
$$
\begin{align}
d&=F(x_i+2,y_i+1.5)\\
&=A(x_i+2)+B(y_i+1.5)+C\\
&=F(x_i+1,y_i+0.5)+A+B\\
&=d+A+B
\end{align}
$$

- 2.当 F(M0) >= 0 时，会选取 Pd 作为直线上显示的像素点，继 M0 之后的下一个中点即为 M1，如下图所示：

![picture1](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot001.png)

当 d >= 0 时，选取 Pd 点。同时可以递推计算下一个 d 的值：
$$
\begin{align}
d&=F(x_i+2,y_i+0.5)\\
&=A(x_i+2)+B(y_i+0.5)+C\\
&=F(x_i+1,y_i+0.5)+A\\
&=d+A
\end{align}
$$

- 3.计算 d 的初始值：

$$
\begin{align}
d_0&=F(x_0+1,y_0+0.5)\\
&=A(x_0+1)+B(y_0+0.5)+C\\
&=F(x_0,y_0)+A+0.5B\\
&=A+0.5B
\end{align}
$$

- 4.综上：

$$
\left\{ 
\begin{align}
d_0&=A+0.5B\\
d&=d+A+B \qquad \text {d < 0}\\
d&=d+A \qquad \text {d >= 0}
\end{align}
\right.
$$

因为定义了A、B、C为整数，为了消除算法中的浮点运算，所以将A、B、C均乘 2。

如下式：
$$
\left\{ 
\begin{align}
d_0&=2A+B\\
d&=d+2A+2B \qquad \text {d < 0}\\
d&=d+2A \qquad \text {d >= 0}
\end{align}
\right.
$$

### （3）优缺点

优点：

- 1.考虑了最大位移方向（对 DDA 的改进）
- 2.消除了浮点运算（对 DDA 的改进）

缺点：

- 1.使用的方程是直线的一般式，算法的使用依赖于方程形式，不够通用。

## 3.Bresenham 算法

### （1）简介

Bresenham 发明的，经典图形学算法。结合了 DDA 和 中点画线法 的优点，不再依赖方程形式，具有通用性，不但可以绘制直线，还可以绘制圆、椭圆等曲线。

### （2）原理

下面只讨论 0 <= k <=1 时的情形。

使用直线斜截式。下图中的 k 即为直线斜率，每个格子边长为 1。

![picture2](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot002.png)

随着横坐标 x 依次递增，只需要判断纵坐标 y 是否加 1 即可。

如上图所示，记录一个值，记为 d，x 每增加 1，d 增加 k，当 d 超过 1 的时候取超过 1 的小数部分。

此时要判断 y 是否加 1，只需判断 d 值是否大于 0.5。若 d > 0.5，则 y 加 1；若 d <= 0.5，则 y 不变。

d 的初始值 d0 = 0。

综上：
$$
\begin{align}
d_0&=0\\
d&=d+k\\
x_{i+1}&=x_i+1\\
y_{i+1}&=y_i \qquad \text {d <= 0.5}\\
y_{i+1}&=y_i+1 \qquad \text {d > 0.5    d = d - 1}
\end{align}
$$
为了避免 d 与浮点数比较，令 e = d - 0.5：
$$
\begin{align}
e_0&=-0.5\\
e&=e+k\\
x_{i+1}&=x_i+1\\
y_{i+1}&=y_i \qquad \text {e <= 0}\\
y_{i+1}&=y_i+1 \qquad \text {e > 0    e = e - 1}
\end{align}
$$
因为斜率 k = delta(y) / delta(x)，为了避免浮点运算，将上式乘以 2 倍的 delta(x)：
$$
\begin{align}
e_0&=-\Delta{x}\\
e&=e+2\Delta{y}\\
x_{i+1}&=x_i+1\\
y_{i+1}&=y_i \qquad \text {e <= 0}\\
y_{i+1}&=y_i+1 \qquad \text {e > 0    e = e - 2delta(x)}
\end{align}
$$
其中 delta(y) 和 delta(x) 均为所绘制的直线的两个端点的坐标之差。

如此一来，便消除了所有的浮点运算。

### （3）优缺点

优点：

- 1.集合了 DDA 和 中点画线法 的优点。
- 2.直线的绘制不依赖于所使用的的方程形式，只需要知道直线两端点坐标即可。（对 中点画线法 的改进）

### （4）实现

下面只实现了 0 <= k <=1 时的情形：

````c++
#include "Bresenham.h"
#include <math.h>
//  0<=k<=1时：
void Bresenham::LineBrecenham(int x0, int y0, int xend, int yend)
{
	int e, dx = xend - x0, dy = yend - y0, x = x0, y = y0;
	e = -dx;
	while (x < xend)
	{
		e += 2 * dy;
		x++;
		if (e > 0)
		{
			y++;
			e -= 2 * dx;
		}
		//putpixel(round(x), round(y));
	}
}
````

### 4.总结

- DDA 算法：把效率提高到了每步只做一个加法
- 中点画线算法：进一步把效率提高到每步只做一个整数加法
- Bresenham 算法：提供了一个更一般的算法，该算法不仅有好的效率，而且有更广泛的适用范围。

# 三、多边形的扫描转换与区域填充算法

多边形类型：

- 凸多边形：任意两点间的连线均在多边形内
- 凹多边形：存在两点连线不在多边形内的
- 含内环的多边形：多边形内包含多边形

多边形的扫描转换 目的：已知多边形顶点，如何找到内部点阵。

## 1.X 扫描线算法

### （1）简介

按照扫描线顺序，计算扫描线与多边形的相交区间，然后填充指定颜色。

### （2）原理

X 扫描线为平行于 X 轴的直线；X 扫描线扫描是由下往上进行扫描；算法核心是按 X 递增顺序排列交点的 X 坐标序列。

![picture3](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot003.png)

步骤：

- 1.确定多边形所占有的最大扫描线数，得到多边形顶点纵坐标 y 的最小和最大值（ymin 和 ymax）

  如上图，由 P2 和 P4 点可知 ymin = 1，由 P7 点可知 ymax = 12。所以最大扫描线数为：12 = 12 - 1 + 1。

- 2.从 y = ymin 到 y = ymax，每次用一条扫描线进行填充。

  ![picture4](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot004.png)

- 3.对一条扫描线进行填充的过程可分为四个步骤：

  - a.**求交**：计算扫描线与多边形各边的交点

    此处可优化的点：扫描线只需要与有效边进行求交运算，而不是所有的边。

  - b.**排序**：把所有交点按 X 坐标的递增顺序进行排序

    把上图中 P1P2 与 X 扫描线的交点称为第一个交点，则第二个交点为 P2P3 与 X 扫描线的交点，第三个交点为 P3P4...，第四个交点为 P4P5...。

  - c.**交点配对**：第一个交点与第二个交点，第三个交点与第四个交点。

  - d.**区间填色**：填充像素颜色。

- 4.注意：当 X 扫描线与多边形顶点相交的时候，此时算作几个交点？

  记 n 为该顶点与 X 扫描线相交的上方的边数：

  - 如 P2 上方边数有 2 条：P1P2 和 P2P3
  - P1 上方的边数有 1 条：P1P7
  - P3 上方的边数为有 0 条

  当 n 为 1 时，算作 1 个交点；当 n 为 0 时，算作 0 个交点；当 n 为 2 时，算作 2 个交点。

### （3）优缺点

缺点：

- 1.效率不高，求交的计算量太大。

## 2.改进的 X 扫描线算法

### （1）简介

该算法的重要意义：提出了图形学中的两个重要思想：

- 1.**扫描线**：当处理图形时按一条条扫描线处理
- 2.**增量**思想

### （2）原理

改进：

- 1.在处理一条扫描线时，仅对与它相交的多边形的边（**有效边**）进行求交运算。

- 2.考虑扫描线的**连贯性**。

  扫描线的连贯性：当前扫描线与各边的交点顺序与下一条扫描线与各边的交点顺序很可能相同或相似。

  ![picture5](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot005.png)

  如上图，蓝色扫描线与红色扫描线与有效边的交点顺序就是相同的，都是先与 P1P4 边相交，再与 P2P3 边相交。
  
- 3.考虑多边形的**连贯性**。

  多边形的连贯性：当某条边与当前扫描线相交时，很可能也与下一条扫描线相交。

  如上图，边 P1P4 与蓝色扫描线相交，同时也与红色扫描线相交。

- 4.为了避免求交运算，引入**特殊的数据结构**：

  - （1）**活性边表**（AET）：把与当前扫描线相交的边称为活性边，并把它们按与扫描线交点 x 坐标递增的顺序存放在一个链表中。

  - （2）**结点内容**：

    - x：当前扫描线与边的交点坐标

    - delta(x)：从当前扫描线到下一条扫描线间 x 的增量

      x 增量的求法见下 （3）。

    - ymax：该边所交的最高扫描线的坐标值 ymax

      通过它可以知道何时可以将该边从活性边表中删除。（详解，见下 （4））

    - next 指针：指向下一个结点

  - （3）随着扫描线的移动，扫描线与多边形的交点和上一次交点相关，如下图所示：

    ![picture6](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot006.png)

    令直线斜率为 k：
  
    $$
    \begin{align}
    k&=\frac{\Delta{y}}{\Delta{x}}\\
    &=\frac{y_{i+1}-y_i}{x_{i+1}-x_i}
    \end{align}
    $$
    
    因为扫描线每次向上移动为 y 轴坐标加 1，即相邻扫描线 y 坐标之差为 1。
    
    变形可得：
    
    $$
    \begin{align}
    x_{i+1}-x_i&=\frac{1}{k}\\
    x_{i+1}&=x_i+\frac{1}{k}\\
    \Delta{x}&=\frac{1}{k}
    \end{align}
    $$
    
  - （4）需要知道一条边何时不再与下一条扫描线相交，以便及时将该边从活性边表中删除，避免与下一条扫描线做无用的求交运算。
  
    该边所交的最高扫描线的坐标值 ymax，当下一条扫描线的 y 值大于 该边的 ymax 的时候，将该边从活性边表中删除。
  
    活性边表的例子，当前扫描线为图中红线时候的活性边表如下图所示：
  
    **注意**：**活性边表** 是需要 **排序** 的：按照交点 x 坐标由小到大排序。
    
    ![picture7](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot007.png)
  
- 5.为了方便 **活性边表** 的建立与更新，构造 **新边表**（NET），用于存放多边形边的信息。

  ![picture8](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot008.png)

  - （1）构造一个 **纵向链表** ：链表长度为多边形所占有的最大扫描线数，如上图，纵向链表长度即为：10 = 10 - 1 + 1。

    链表的每一个结点称为一个 **吊桶** ，每个 **吊桶** 对应一条扫描线。

  - （2）**新边表 NET** ：由多个链表构成，链表中的每个结点都包含对应边的信息。结点的结构：

    ![picture9](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot009.png)

    - ymax ：该边所包含的所有像素点中纵坐标的最大值。
    - xmin ：该边所包含的所有像素点中纵坐标最小的像素点的横坐标的值。
    - 1/k ：该边斜率的倒数。
    - next ：指向下一个结点的指针。下一个结点对应的边与当前边拥有相同的 xmin 。

  - （3）**新边表 NET** 例子：新边表包含一个纵向链表以及四个单链表

    ![picture10](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot010.png)

- 6.新的扫描线进行扫描时，需要经过 3 步：

  - （1）将 **新边表 NET** 中和扫描线对应的边结点（单链表）用插入排序法插入 **活性边表 AET** 中。
  - （2）查看 **活性边表 AET** 中是否有边需要被删除。
  - （3）将 **活性边表 AET** 中各结点的 x 值递增 delta(x) = 1/斜率。

### （3）优缺点

优点：

- 1.提高了算法效率，引进了：
  - 增量思想
  - 连贯性思想
  - 构建了一套特殊的数据结构（活性边表 AET 和 新边表 NET）
- 2.可以实现对任意类型的多边形的区域填充（凸、凹、含内环的多边形）

缺点：

- 1.无法实现对未知边界的区域填充。

### （4）伪代码

![picture11](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot011.png)

## 3.边缘填充算法

### （1）简介

对多边形每条边逐边向右取补。

### （2）原理

流程如下图：

![picture12](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot012.png)

### （3）优缺点

优点：

- 1.算法简单

缺点：

- 1.对于复杂图形，被重复访问的像素点很多

### （4）改进：可以使用栅栏填充算法

（略...）

## 4.边标志算法

### （1）简介

先画边界后填色。

基本思想：

- 用一种特殊的颜色在帧缓冲器中将多边形的边界勾画出来
- 将着色的像素点依 x 坐标递增的顺序两两配对
- 将每一对像素所构成的扫描线区间内的所有像素置为填充色

### （2）原理

分为两个步骤：

- Step1：打标记

  对多边形的每条边进行直线扫描转换（将多边形边界所经过的像素打上标记）

  此处打标记原理同 X 扫描线算法中的 “**当 X 扫描线与多边形顶点相交的时候，此时算作几个交点？**”一样。

- Step2：填充

  为每个像素点设置一个 bool 变量： ***Inside*** ，表示该像素点是否在多边形内部，是否需要填色。

  ***Inside*** 初始值为 *false*；每当遇到标记点时就取反，然后根据 ***Inside*** 的值进行颜色填充（为 true 则填充，反之不填充）

  如下图所示：

  ![picture13](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot013.png)

### （3）优缺点

优点：

- 1.对每个像素仅访问一次，避免对同一像素的大量重复赋值。（对 边缘填充算法 和 栅栏填充算法 的改进）
- 2.使用软件实现该算法，速度与改进后的 X 扫描线算法 速度相当；但用硬件实现，速度大大提高。

缺点：

- 1.仍然需逐条扫描线地对帧缓存中的元素进行搜索和比较。


## 5.区域填充算法

### （1）简介

**区域**：已经表示成点阵形式的填充图形，是像素的集合。包含有内点和边界点。

**区域填充**：将区域内的一点（种子点）赋予给定的颜色，然后将该颜色扩展到整个区域内的过程。要求区域是连通的。

区域分为：四向连通区域和八向连通区域：

![picture14](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot014.png)

### （2）原理

简单的四连通种子填充算法（区域填充递归算法）：

![picture15](https://huskytgame.github.io/images/in-post/shader/2020-01-11-计算机图形学--光栅图形学算法_基础/ScreenShot015.png)

### （3）优缺点

优点：

- 1.递归实现，算法简单。

缺点：

- 1.栈结构占空间
- 2.部分像素会多次入栈，降低算法效率
- 3.递归效率低，进栈/出栈操作费时费内存。

改进：**区域填充的扫描线算法**

# 四、裁剪算法











# 五、反走样算法









# 六、消隐算法







