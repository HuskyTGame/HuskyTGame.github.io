---
layout: article
title:  "初级--多光源光照"
categories: shader
image:
    teaser: /in-post/shader/2019-09-15-初级--多光源光照/ScreenShot000.png
---

## 写在前面

本文将在上一篇[单一光源光照](https://huskytgame.github.io//shader/初级-单一光源光照/)中的PBS光照模型的基础上增加对多光源的支持(***使用前向渲染***)。全篇基于Unity2018.3.2。

在PC前的各位读者，建议下载MD文件阅读，观感更好。若有图片无法显示，请开启网络。**欢迎转载，只需注明转载来源地址即可。**[MD文件及工程Package下载地址](https://pan.baidu.com/s/1ApzTBeqRL6Ib8_yTQOTa5w)（提取码：4c1s）

## 创建自己的Shader包含文件

为了给我们的着色器增加多光源支持，我们需要增加多个Pass通道。新增的Pass通道包含了几乎相同的代码。为了减少重复代码，我们将上一篇的代码做成自己的**Shader包含文件**(Shader Include File)。

首先，复制上一篇的基于PBS的光照Shader；然后变更文件后缀名为"***.cginc***"；然后打开变更好后缀的cginc文件，将``#include "UnityPBSLighting.cginc"``之前的代码全部删除，将从"ENDCG"开始的代码全部删除；最后在开头和结尾加上：

````CG/HLSL
#if !defined(MY_LIGHTING_INCLUDED)
#define MY_LIGHTING_INCLUDED
......
#endif
````

开头加上的宏可以保证我们的自定义包含文件不会被其他Shader重复Include。避免重复引入造成的变量重复命名的编译错误。

## 多光源

我们将会使用前向渲染来实现多光源支持。

### 1.创建文件夹结构：

使用[HTUtility工具](https://huskytgame.github.io//framework/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/)(Shift+Alt+G)创建合适的文件夹结构，重命名Root文件夹为"2_多光源"。在场景中创建"Plane"，Reset到原点位置并旋转使其正对摄像机。创建Material，命名为"MultipleLightingMat"；创建Unlit Shader，命名为"MultipleLighting"。选择"MultipleLightingMat"的Shader为"MultipleLighting"，并将材质赋值给场景中的"Plane"。

![picture0](https://huskytgame.github.io/images/in-post/shader/2019-09-15-初级--多光源光照/ScreenShot000.png)

### 2.光源类型：

平行光、点光、聚光灯，面光源等可见[Unity手册](https://connect.unity.com/doc/Manual/Lighting)介绍。

### 3.前向渲染路径：

#### (1)概述：

前向渲染一般包含有两个Pass通道，一个是"ForwardBase"Pass通道，一个是"ForwardAdd"Pass通道。

#### (2)相关设置：

在Unity中对于光照的计算方式有三种，分别为逐像素[^逐像素是？]、逐顶点[^逐顶点是？]、球谐函数(SH)。

##### 逐像素：

逐像素计算光照是效果最好的，但性能消耗也最高，所以Unity限制了可使用逐像素计算光照的光源最大数量。

逐像素计算光照效果：

![picture1](https://huskytgame.github.io/images/in-post/shader/2019-09-15-初级--多光源光照/ScreenShot001.png)

具体设置在"***Edit--Project Settings--Quality--Rendering***"中的"***Pixel Light Count***"。

![picture2](https://huskytgame.github.io/images/in-post/shader/2019-09-15-初级--多光源光照/ScreenShot002.png)

可设置范围：[0,4]。

即使设置为0，也不会影响逐像素计算**主光**(最重要的平行光[^最重要的平行光是？])，主光的计算默认为逐像素，不会占用***PiexlLightCount***个数。

##### 逐顶点：

逐顶点计算出来的效果一般，不够平滑，因为其计算是在各个顶点之间插值计算得到的结果，而顶点数较少，所以插值结果不够平滑，但也因此拥有较好的性能。

逐顶点计算光照效果：

![picture3](https://huskytgame.github.io/images/in-post/shader/2019-09-15-初级--多光源光照/ScreenShot003.png)

当场景中的光源数量大于***PiexlLightCount***个数时，会采用逐顶点方式计算光照。同样的逐顶点计算也有限制个数。Unity默认的限制个数为4个，而且无法设置变更。

逐顶点相对于逐像素的缺点在于：不支持光照剪影和法线贴图。

##### 球面谐波函数(SH)：

简称球谐函数(SH)，球谐函数光源的渲染速度很快。当场景中的光源数量超过逐像素个逐顶点的最大个数之和时，超出的光源部分会使用球谐函数计算。

这些光源的CPU成本很低，并且使用GPU成本几乎为零。球谐函数会在"ForwardBase"中常驻计算，且成本不变。

球谐函数也是逐顶点计算的，所以同样拥有逐顶点的缺点：不支持光照剪影和法线贴图。除此之外，球谐函数光照只影响漫反射光照(diffuse)，而且球谐函数光照频率很低，无法实现快速光照过渡。最后，球谐函数光照不属于局部光照，所以当点光源和聚光灯以SH方式计算的时候，如果靠近物体表面，是不会有正确的光照显示的，看起来就像没有光照一样，因为SH光照被计算到了间接光照中。

#### (3)前向渲染的Pass通道：

##### "ForwardBase"基础通道：

在"ForwardBase"中会以逐像素的方式计算**主光**，除此之外还会以逐顶点的方式计算最多4个次级光，以及会以逐顶点方式使用球谐函数(SH)计算额外的光照。

##### "ForwardAdd"额外通道：

在"ForwardAdd"中只会计算逐像素光照，而且每个逐像素光照的计算都会使用一个"ForwardAdd"通道。

也就是说，当场景中存在n个物体，以及m个逐像素光源时(m<=4，且不包含主光)，此时光源计算的Batches=n+n*m；其中n为"ForwardBase"通道，n * m为"ForwardAdd"通道。

增加逐像素光数量会成倍增加Batches，而Batches过多会在CPU处产生性能瓶颈。所以在移动端逐像素光要慎用。

更多关于前向渲染的信息可以查看[Unity官方手册](https://connect.unity.com/doc/Manual/RenderTech-ForwardRendering)。

### 4.Shader编写：

由于我们自定义了自己的光照包含文件，所以大部分光照代码在光照包含文件中写即可，在Shader中只需要对Pass通道进行相关设置即可。

打开Shader文件"MultipleLighting"：

先删除所有和雾相关的代码，在这里我们不需要雾。

将之前的属性块中的代码完全迁移过来：

````ShaderLab
Properties
{
	_Tint("Tint",COLOR) = (1,1,1,1)
	_MainTex ("Albedo", 2D) = "white" {}
	//告诉Unity，金属值也需要进行Gamma校正
	[Gamma]_Metallic("Metallic",Range(0,1)) = 0//金属般的
	_Smoothness("Smoothness",Range(0,1)) = 0.1//物体表面平滑程度，越平滑越容易聚焦光线、光点越小
}
````

将之前的"SingleLighting_MetallicWorkflow"Shader中的Pass通道的代码完全迁移过来，然后删除Pass通道中从#include开始直到片元函数结束的部分。

````ShaderLab
Pass
{
	Tags{"LightMode"="ForwardBase"}//前向渲染

	CGPROGRAM
	#pragma vertex vert
	#pragma fragment frag

	//使用PBS
	#pragma target 3.0

	ENDCG
}
````

增加一个"ForwardAdd"Pass通道：

由于新增Pass通道是用于计算逐像素的次级光，次级光颜色应与基础通道中光照颜色叠加显示，所以需要加上混合指令：``Blend One One``，此后该Pass通道计算出的颜色就会添加到帧缓冲区与原帧缓冲区颜色混合。

在基础通道中GPU会将片元的深度信息写入深度缓冲区(Z Buffer)中，只有距离摄像机近的片元会渲染出来。这个工作我们没有必要在"ForwardAdd"通道中再做一次。通过添加指令"ZWrite Off"可以告诉GPU该Pass通道不需要进行深度写入。

````ShaderLab
Pass
{
	Tags{"LightMode"="ForwardAdd"}//前向渲染
	Blend One One//次级光和主光混合
	ZWrite Off//计算次级光时无需重复计算深度缓冲

	CGPROGRAM
	#pragma vertex vert
	#pragma fragment frag

	//使用PBS
	#pragma target 3.0

	ENDCG
}
````











[^逐像素是？]: 逐像素指的是在片元着色器中计算光照颜色。
[^逐顶点是？]: 逐顶点指的是在顶点着色器中计算光照颜色，然后将颜色计算结果通过插值寄存器传递给片元着色器。由于顶点数显著小于片元数(像素数量)，所以逐顶点的性能较好，但效果没有逐像素的平滑。
[^最重要的平行光是？]: 一般来说场景只需要一个平行光就足够了，此时该平行光即为最重要的平行光。当场景中存在多个平行光时，谁为最重要的平行光依赖于平行光的设置和光照强度。首先看RenderMode设置，为Important的即为重要，Auto则会根据系统中的质量设置来判断是否为Important。在重要等级相同的情况下再进行光源强度的比较，Intensity值大的为重要。