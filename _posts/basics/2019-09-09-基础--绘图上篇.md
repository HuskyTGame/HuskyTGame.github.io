---
layout: article
title:  "基础--绘图上篇"
categories: basics
image:
    teaser: /in-post/basics/2019-09-09-基础--绘图上篇/CardioidPlusTwist.png
---

![GIF1](https://huskytgame.github.io/images/in-post/basics/2019-09-09-基础--绘图上篇/CardioidPlusTwist.gif)


## 写在前面

本文将讲述如何在Unity中绘制数学曲线。此文旨在为渲染打下基础，可视化的观察、感受各类数学曲线。

## 1.准备工作

首先调整摄像机，让我们可以刚好观察到xy平面，以后的图像都会绘制在xy平面上。

在场景中创建一个空物体，取名为"BuildingAGraph"，它将成为我们与Unity交互的主入口。

创建一个Cube，取名为"Point"，即为以后我们图像上绘制的小点；为Cube创建一个材质球"PointMat"和一个Shader脚本"PointColor"，将Shader脚本赋给材质球，然后将材质球赋给Cube。我们要通过Shader脚本为图像着色，通过颜色来反映图像上小点的空间位置信息。将Cube做成预制体，后续我们要加载此预制体。

## 2.绘制简单曲线

首先，我们需要明确曲线绘制的范围，为了便于我们观察，我们规定曲线绘制在[-1,1]之间，即曲线上的点在xyz坐标轴上的取值范围均为[-1,1]。

好了，在规定好绘图区域后，我们可以开始了。

我们选择使用Cube作为图上的小点，为了方便实例化Cube，我们定义一个公共变量，以便在编辑器下通过拖拽轻松获取Cube的引用[^可以做得更好吗？]。

``` csharp
        public Transform PointPrefab;
```

我们需要在[-1,1]范围内生成多少个Cube以满足我们绘图的目的呢？我们可以把这个变化点抽象出来，做成公共变量便于我们修改调整。我们为其取名为分辨率Resolution，即绘制一个面上的曲线一共需要多少个Cube(像素点)。

``` csharp
        [Range(10, 100)]
        public int Resolution = 10;// 分辨率
```

在绘图时会创建许多Cube，为此我们使用一个数组来存储。

``` csharp
        private Transform[] mPoints;
```

下面要开始写比较重要的函数了：我们的绘图函数。我们需要在函数中创建出所有我们需要的Cube，将其存放在我们定义的数组中，以便后续绘图使用。数组大小如何规定呢？由于分辨率Resolution定义的是一个面上(xy平面)Cube的个数，在后续绘图中我们还需要处理z轴方向的事情，也就是我们会扩展到绘制3D曲面，所以此处我们超前一点将数组的大小定义为分辨率的平方[^平方的含义]。

``` csharp
        private void BuildGraph(GraphFunction3D function)
        {
            mPoints = new Transform[Resolution * Resolution];//Resolution个切片组成
        }
```

我们知道一个原始的Cube默认大小Scale为(1,1,1)，而我们规定了绘图范围[-1,1]以及分辨率，所以我们需要处理每个Cube的大小，让其适应我们的分辨率大小。

``` csharp
        private void BuildGraph(GraphFunction3D function)
        {
			......
            float step = 2f / Resolution;
            Vector3 scale = Vector3.one * step;
        }
```

现在我们可以加载我们的点Cube了，加载之后，设置它的Scale、父节点，并将其添加到数组中。

``` csharp
        private void BuildGraph(GraphFunction3D function)
        {
			......
            for (int i = 0; i < mPoints.Length; i++)
            {
                Transform point = Instantiate(PointPrefab);
                point.localScale = scale;
                point.SetParent(transform, false);
                mPoints[i] = point;
            }
        }
```

在Unity的生命周期函数的Start中对所有Cube进行加载。

``` csharp
        private void Start()
        {
            BuildGraph();
        }
```

在加载完成之后，我们需要在Update中每帧更新我们的Cube位置，来显示我们的图形。我们将图像更新的方法提取成一个单独的方法[^为什么需要图像更新方法]。

现在我们有两个思路，一个是通过动画显示绘图的过程，一个是直接在一帧中绘制完成。我们可以先简单点，将动画部分放到后面完成。

我们可以先固定一个z值，然后绘制xy平面的图形，然后在沿着z轴，依次绘制在不同z值下的xy平面。那么问题来了，如果在三维空间下绘制图形的话，我们每个图形上的点都需要三个信息，即三个坐标轴上的坐标。我们如何确定每个Cube的三维坐标呢？方法很简单，就像我们在中学学到的一样：我们首先确定两个坐标，比如x轴上的和z轴上的，然后根据我们想绘制的曲线的方程来求出y轴坐标。

这里说到了曲线方程，我们知道曲线方程有显式和隐式之分[^什么叫做显式隐式？]。对于隐式的处理比较复杂，我们先来看看简单的显式方程。对于每一个方程我们应该将他们单独提取成一个函数，即输入参数x和z的值，返回y值。比如我们先来看看最简单的正弦函数。[^x为什么要乘以π？]

$$
y=sin\pi x
$$


``` csharp
        private static Vector3 SineFunction(float x, float z)
        {
            Vector3 p;
            p.x = x;
            p.y = (float)Math.Sin(PI * x);
            p.z = z;
            return p;
        }
```

然后将曲线方程应用到图形更新函数中。应用的方法有很多种：可以直接在方法内部使用，也可以作为参数传递给方法。为了后续的扩展方便，我们选择使用委托，将曲线方法当做参数传递给图形更新函数。我们新建一个脚本"GraphFunction3D"来存放我们定义的委托。

``` csharp
    public delegate Vector3 GraphFunction3D(float x, float z);
```

如此一来我们可以将曲线方法当做参数传递给图形更新函数了。

``` csharp
        private void UpdateGraph(GraphFunction3D function)
        {
            float step = 2f / Resolution;
            for (int i = 0, z = 0; z < Resolution; z++)
            {
                float z = -1f + step * z;
                for (int x = 0; x < Resolution; x++, i++)
                {
                    float x = -1f + step * x;
                    mPoints[i].localPosition = function(x, y);
                }
            }
        }
```

我们在Update中调用图形更新函数

``` csharp
        private void Update()
        {
            UpdateGraph(SineFunction);
        }
```

现在让我们看一看Unity绘制出来的sin曲线如何吧，在编辑界面的检视面板中，我们拖拽好Cube预制体，并设置好Resolution为10。

![picture1](https://huskytgame.github.io/images/in-post/basics/2019-09-09-基础--绘图上篇/ScreenShot001.png)

第一个曲线绘制出来了，虽然很单调，但总算完成了第一步。接下来我们来丰富一下图形的颜色。

## 3.为图形添加颜色

打开我们之前创建好的Shader脚本，删去所有注释和不需要的主纹理贴图和颜色基调，在输入结构体中传入物体的世界空间下的坐标，在表面函数中通过物体世界空间坐标为***反照率***[^反照率Albdo]赋值

```ShaderLab
Shader "Custom/PointColor"
{
    Properties
    {
        _Glossiness ("Smoothness", Range(0,1)) = 0.5
        _Metallic ("Metallic", Range(0,1)) = 0.0
    }
    SubShader
    {
        Tags { "RenderType"="Opaque" }
        LOD 200
        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows
        #pragma target 3.0

        struct Input
        {
			float3 worldPos;
        };

        half _Glossiness;
        half _Metallic;

        UNITY_INSTANCING_BUFFER_START(Props)
        UNITY_INSTANCING_BUFFER_END(Props)

        void surf (Input IN, inout SurfaceOutputStandard o)
        {
			o.Albedo.rg = IN.worldPos.xy * 0.5+0.5;
            o.Metallic = _Metallic;
            o.Smoothness = _Glossiness;
            o.Alpha = 1;
        }
        ENDCG
    }
    FallBack "Diffuse"
}
```

由于我们规定各坐标轴上的点的坐标的取值范围为[-1,1]，所以通过此操作`o.Albedo.rg = IN.worldPos.xy * 0.5+0.5;`可以将值域映射到[0,1]，以满足颜色显示的需求。直接将透明度设置为1`o.Alpha = 1;`，我们不需要物体透明。

现在，让我们来看一看拥有颜色的图形是什么样的吧。

![picture2](https://huskytgame.github.io/images/in-post/basics/2019-09-09-基础--绘图上篇/ScreenShot002.png)

好多了，现在图形上点的x坐标反映了R颜色通道，y坐标反映了G颜色通道。但现在图形显示得太不流畅了，我们来提高一点分辨率，将Resolution值由10提高到50，来看看效果如何。

![picture2](https://huskytgame.github.io/images/in-post/basics/2019-09-09-基础--绘图上篇/ScreenShot003.png)

## 让图形动起来

现在我们已经绘制出来了一条拥有颜色信息的曲线，接下来我们来稍作修改，为图形丰富一点运动元素。





[^可以做得更好吗？]: 当然，在很多大型的项目中，我们一般不会进行拖拽，因为拖拽会让我们的项目和Unity之间耦合度增加，这是我们不愿看到的。但在此处，我们只是一个小案例，所以没有必要使用复杂的加载方式让我们的代码变得复杂，我们可以简单点、轻松点。
[^平方的含义]: 从xy面上看我们一个面上有Resolution个Cube，同理从侧面，即yz面看，我们一个面也应该有Resolution个Cube，相乘即为平方。
[^为什么需要图像更新方法]: 因为往后我们会拓展，使图像动起来。
[^什么叫做显式隐式？]: 能够求出解析解的即为显式，否则为隐式；解析解即可以写成y=f(x,z)，方程左边存在y，而右边完全不存在y。
[^x为什么要乘以π？]: 为了能在[-1,1]区域内显示完整的一个周期的sin波形。
[^反照率Albdo]: 物质的漫反射颜色，Albdo是拉丁文表示白色。
