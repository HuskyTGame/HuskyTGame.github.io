---
layout: article
title:  "2019-11-09-Zenject学习笔记"
categories: framework
image:
    teaser: /in-post/framework/2019-11-09-Zenject学习笔记/DefaultImg.jpg
---

# 目录

[TOC]

## 一、快速入门

一个最简单的依赖注入例子：

- Step1：在*Hierarchy*中通过"*鼠标右键--Zenject--Scene Context*"创建***SceneContext***场景上下文。

- Step2：通过"*鼠标右键--Zenject--Mono Installer*"创建***Mono Installer***并命名为*QuickStartInstaller*。

- Step3：在SceneContext上挂载*QuickStartInstaller*脚本，并在*Scene Context*组件中添加*Mono Installer*，然后将自身拖拽进去。如下图所示：

  ![picture0](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot000.png)

- Step4：在场景中创建空物体*HelloWorldExample*，并创建同名脚本并拖拽至该物体上。

- Step5：编写脚本：

  ````csharp
      public class QuickStartInstaller : MonoInstaller
      {
          public override void InstallBindings()
          {
              //使用容器Container绑定BluetoothService
              //并使其作为单例
              Container.Bind<BluetoothService>()
                  .AsSingle();
          }
          public class BluetoothService
          {
              public void Connect()
              {
                  Debug.Log("Examples--1.QuickStart--" + "蓝牙连接成功");
              }
          }
      }
  ````
  
````csharp
      public class HelloWorldExample : MonoBehaviour
      {
          //注入
          [Inject] private QuickStartInstaller.BluetoothService mBluetoothService;
          private void Start()
          {
              mBluetoothService.Connect();
          }
      }
````

*CTRL+SHIFT+R*运行后，控制台打印输出：``Examples--1.QuickStart--蓝牙连接成功``

## 二、基本使用

### 1.依赖注入

依赖注入：给当前脚本提供所需对象的实例，所需要的对象的实例需要通过``[Inject]``属性进行标记。

提供这些对象的操作，叫做注入操作。

**Zenject**的注入模式有4种：

- Constructor Injection：构造函数注入
- Field Injection：成员变量（域）注入
- Property Injection：属性器注入
- Method Injection：方法注入

#### （1）Constructor Injection（构造函数注入）

- 解释：通过构造方法传递实例
- 工作原理：根据构造方法的参数类型自动申请实例。（参数可以有多个）

步骤Step1~4与*快速入门*中的类似，仅修改相关名称。

Step5：编写脚本：

````csharp
    public class ConstructorInjectionInstaller : MonoInstaller
    {
        public override void InstallBindings()
        {
            Container.Bind<BluetoothService>()
                .AsSingle();
        }
        public class BluetoothService
        {
            public void Connect()
            {
                Debug.Log("Examples--2.ConstructorInjection构造函数注入--" + "蓝牙连接成功");
            }
        }
    }
````

**注意：**

- MonoBehaviour的对象创建过程由Unity引擎决定，所以无法在脚本的构造函数中进行依赖注入，而是使用名为*Constructor*的函数进行构造函数注入。
- *Constructor*函数上需要进行*Inject Attribute*注入属性标记：``[Inject]``。
- 函数名称不一定为*Constructor*，在脚本中，构造函数注入本质上是***Method Inject（方法注入）***。

````csharp
    public class ConstructorInjectionExample : MonoBehaviour
    {
        private ConstructorInjectionInstaller.BluetoothService mBluetoothService;
        //构造函数注入
        [Inject]
        void Constructor(ConstructorInjectionInstaller.BluetoothService bluetoothService)
        {
            mBluetoothService = bluetoothService;
        }
        private void Start()
        {
            mBluetoothService.Connect();
        }
    }
````

运行后控制台打印输出：``Examples--2.ConstructorInjection构造函数注入--蓝牙连接成功``。

#### （2）Field Injection（成员变量（域）注入）

````csharp
    public class FieldInjectionInstaller : MonoInstaller
    {
        public override void InstallBindings()
        {
            Container.Bind<BluetoothService>()
                .AsSingle();
        }
        public class BluetoothService
        {
            public void Connect()
            {
                Debug.Log("Examples--3.FieldInjection成员变量（域）注入--" + "蓝牙连接成功");
            }
        }
    }
````

**原理**：遍历通过*Inject Attribute*标记的成员变量，进行赋值。

````csharp
    public class FieldInjectionExample : MonoBehaviour
    {
        //成员变量（域）注入
        [Inject] private FieldInjectionInstaller.BluetoothService mBluetoothService;
        private void Start()
        {
            mBluetoothService.Connect();
        }
    }
````

运行后控制台打印输出：``Examples--3.FieldInjection成员变量（域）注入--蓝牙连接成功``。

#### （3）PropertyInjection（属性器注入）

````csharp
    public class PropertyInjectionInstaller : MonoInstaller
    {
        public override void InstallBindings()
        {
            Container.Bind<ResLoader>()
                .AsSingle();
        }
        public class ResLoader
        {
            public T Load<T>(string name) where T : Object
            {
                Debug.Log("Examples--4.PropertyInjection属性器注入--" + typeof(T) + name);
                return default(T);
            }
        }
    }
````

**原理**：遍历通过*Inject Attribute*标记的属性器，调用``SetProperty``方法进行赋值。

````csharp
    public class PropertyInjectionExample : MonoBehaviour
    {
        //属性器注入
        [Inject]
        public PropertyInjectionInstaller.ResLoader ResLoader { get; private set; }
        private void Start()
        {
            ResLoader.Load<GameObject>("TestGO");
        }
    }
````

运行后控制台打印输出：``Examples--4.PropertyInjection属性器注入--UnityEngine.GameObjectTestGO``。

#### （4）Method Injection（方法注入）

````csharp
    public class MethodInjectionInstaller : MonoInstaller
    {
        public override void InstallBindings()
        {
            Container.Bind<ResLoader>()
                .AsSingle();
        }
    }
    public class ResLoader
    {
        public T Load<T>(string name) where T : Object
        {
            Debug.Log("Examples--5.MethodInjection方法注入--" + typeof(T) + name);
            return default(T);
        }
    }
````

**原理**：遍历标记*Inject Attribute*的方法，并遍历方法中的参数，为参数设置实例。（MonoBehaviour中的构造函数注入其实用的就是方法注入）

````csharp
    public class MethodInjectionExample : MonoBehaviour
    {
        private ResLoader mResLoader1;
        private ResLoader mResLoader2;
        //方法注入
        [Inject]
        private void Method(ResLoader resLoader1, ResLoader resLoader2)
        {
            mResLoader1 = resLoader1;
            mResLoader2 = resLoader2;
        }
        private void Start()
        {
            mResLoader1.Load<GameObject>("1号");
            mResLoader1.Load<GameObject>("2号");
            Debug.Log(mResLoader1.GetHashCode());
            Debug.Log(mResLoader2.GetHashCode());
        }
    }
````

运行后控制台打印输出：``Examples--5.MethodInjection方法注入--UnityEngine.GameObject1号``；

``Examples--5.MethodInjection方法注入--UnityEngine.GameObject2号``；

``-630497024``；``-630497024``。因为``ResLoader``是单例，所以其HashCode相同。

#### （5）依赖注入总结

- ***Zenject***中依赖注入模式：（4种）

  Constructor Injection**构造函数注入**：在MonoBehaviour中本质上就是方法注入

  Filed Injection**成员变量（域）注入**

  Property Injection**属性器注入**

  Method Injection**方法注入**

- **推荐使用**构造函数注入（.Net Core只支持构造函数注入）

### 2.绑定

绑定最核心的功能就是向Container注册类型。

相关概念：

- Container--容器
- Bind--绑定方法
- ResLoader--类型

#### （1）DiContainer的使用

DiContainer：*Dependency Injection Container*--依赖注入的容器。

DiContainer的职责：管理绑定，管理依赖关系。

包含三个API：

- ``Bind<XXX>().To(YYY).AsZZZ()``：绑定。（``AsZZZ()``为Scope作用域）
- ``Resolve<XXX>()``：解析，作用是获取实例。
- ``Inject<XXX>()``：注入

##### （a）Resolve解析：在Container中寻找指定对象实例，若不存在则创建实例并返回。

````csharp
    public class DiContainerExample : MonoBehaviour
    {
        private void Start()
        {
            //创建Container进行绑定操作
            var container = new DiContainer();
            container.Bind<ResLoader>()
                .AsSingle();
            //Resolve解析：
            //先在Container中寻找是否有ResLoader实例，如果没有就创建并返回。
            ResLoader resLoader = container.Resolve<ResLoader>();
            resLoader.Load<GameObject>("PrefabA");
        }
    }
````

##### （b）Inject注入：遍历当前类，将标记有Inject Attribute的通过Resolve获取实例。

````csharp
    public class DiContainerInjectExample : MonoBehaviour
    {
        [Inject] private ResLoader mResLoader;
        private void Start()
        {
            var container = new DiContainer();
            container.Bind<ResLoader>()
                .AsSingle();
            //Inject包含两步操作：
            //1.遍历当前类
            //2.将标记有Inject Attribute的通过Resolve获取实例。
            //Resolve解析类型：查找实例并返回，若不存在则创建。
            container.Inject(this);
            mResLoader.Load<GameObject>("PrefabB");
        }
    }
````

##### （c）BindTo操作：约定类型与结果类型绑定

``Bind<ContractType>().To<ResultType>()``：

- ContractType：约定类型（类型不限，一般用接口）
- ResultType：结果类型（**Result is ContractType**）
- 根据约定类型解析出结果类型。

一个约定类型绑定一个结果类型：

````csharp
    public class BindToExample : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            //将约定类型与结果类型进行绑定
            container.Bind<IBluetoothService>()
                .To<BluetoothService>()
                .AsSingle();
            //约定类型进行解析（查找），返回结果类型实例。
            var bluetoothService = container.Resolve<IBluetoothService>();
            bluetoothService.Connect();
        }
        interface IBluetoothService
        {
            void Connect();
        }
        public class BluetoothService : IBluetoothService
        {
            public void Connect()
            {
                Debug.Log("蓝牙连接成功");
            }
        }
    }
````

``Bind(params Type[] contractTypes).To<ResultType>()``

多个约定类型绑定一个结果类型：

````csharp
    public class BindToExample2 : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            container.Bind<IClassA>()
                .To<ClassA>()
                .AsTransient();
            container.Bind<ClassABase>()
                .To<ClassA>()
                .AsTransient();
            container.Bind<ClassA>()
                .To<ClassA>()
                .AsTransient();
            //绑定多个类型的简化方式：
            container.Bind(typeof(IClassA), typeof(ClassABase), typeof(ClassA))
                .To<ClassA>()
                .AsSingle();
            Debug.Log(container.Resolve<IClassA>().GetType());
            Debug.Log(container.Resolve<ClassABase>().GetType());
            Debug.Log(container.Resolve<ClassA>().GetType());
        }
        interface IClassA { }
        public abstract class ClassABase : IClassA { }
        public class ClassA : ClassABase { }
    }
````

##### （d）Scope作用域：AsSingle/AsTransient/AsCached

![picture1](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot001.png)

###### AsSingle：以单例形式存在

不论Container容器解析多少次都为同一个对象。

测试脚本：

````csharp
    public class AsSingleExample : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            container.Bind<ResLoader>()
                .AsSingle();
            //单例哈希值相同
            Debug.Log(container.Resolve<ResLoader>().GetHashCode());
            Debug.Log(container.Resolve<ResLoader>().GetHashCode());
        }
    }
````

运行结果：（哈希值相同=>每次解析返回相同的对象）

![picture2](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot002.png)

###### AsTransient：每次解析时返回新的实例

Transient意为短暂的。

测试代码：

````csharp
    public class AsTransientExample : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            container.Bind<ResLoader>()
                .AsTransient();
            //Transient每次解析获取不同实例，哈希值不相同
            Debug.Log(container.Resolve<ResLoader>().GetHashCode());
            Debug.Log(container.Resolve<ResLoader>().GetHashCode());
        }
    }
````

运行结果：（哈希值不同=>每次解析返回对象不同的实例）

![picture3](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot003.png)

###### AsCached：为每个约定类型创建一个单例

Cached意为缓存。

AsCached：约定类型第一次解析时，创建一个新的实例。约定类型再次进行解析时，返回首次解析时创建的实例。（为每个约定类型创建一个单例实例）

测试代码：

````csharp
    public class AsCachedExample : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            //AsCached：
            //约定类型第一次解析时，创建一个新的实例
            //约定类型再次进行解析时，返回首次解析时创建的实例
            //为每个约定类型创建一个单例实例
            container.Bind<IClassB>()
                .To<ClassB>()
                .AsCached();
            container.Bind<ClassBBase>()
                .To<ClassB>()
                .AsCached();
            container.Bind<ClassB>()
                .To<ClassB>()
                .AsCached();
            //相同约定类型为一组
            //每一组的哈希值相同
            Debug.LogFormat("IClassB：{0}", container.Resolve<IClassB>().GetHashCode());
            Debug.LogFormat("IClassB：{0}", container.Resolve<IClassB>().GetHashCode());
            Debug.LogFormat("ClassBBase：{0}", container.Resolve<ClassBBase>().GetHashCode());
            Debug.LogFormat("ClassBBase：{0}", container.Resolve<ClassBBase>().GetHashCode());
            Debug.LogFormat("ClassB：{0}", container.Resolve<ClassB>().GetHashCode());
            Debug.LogFormat("ClassB：{0}", container.Resolve<ClassB>().GetHashCode());
        }
        interface IClassB { }
        abstract class ClassBBase : IClassB { }
        class ClassB : ClassBBase { }
    }
````

运行结果：（每一组的哈希值相同=>AsCached为每个约定类型创建一个单例）

![picture4](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot004.png)

###### Scope作用域代码总结

- AsSingle：以单例形式存在，不论解析多少次都为同一个对象。
- AsTransient：每次解析时返回新的实例。
- AsCached：约定类型第一次解析时，创建一个新的实例。约定类型再次进行解析时，返回首次解析时创建的实例。（为每个约定类型创建一个单例实例）。

##### （e）自动绑定接口

###### 自动绑定接口``BindInterfacesTo<ClassC>()``

将目标类型ClassC所有的接口作为约定类型与ClassC进行绑定

**注意**：只能是**接口**，抽象类和普通类均不行。

测试代码：

````csharp
    public class BindInterfacesToExample : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            //自动将ClassC所有接口与ClassC进行绑定
            container.BindInterfacesTo<ClassC>()
                .AsSingle();
            Debug.LogFormat("IInterfaceA：{0}", container.Resolve<IInterfaceA>().GetHashCode());
            Debug.LogFormat("IInterfaceB：{0}", container.Resolve<IInterfaceB>().GetHashCode());
        }
        interface IInterfaceA { }
        interface IInterfaceB { }
        class ClassC : IInterfaceA, IInterfaceB { }
    }
````

###### 自动绑定接口和自身``BindInterfacesAndSelfTo<ClassC>()``

将目标类型ClassC所有的接口和自身作为约定类型与ClassC进行绑定。（不能为抽象类）

测试代码：

````csharp
    public class BindInterfacesAndSelfToExample : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            //自动将ClassD所有接口和自身与ClassD进行绑定
            container.BindInterfacesAndSelfTo<ClassD>()
                .AsSingle();
            Debug.LogFormat("IInterfaceA：{0}", container.Resolve<IInterfaceA>().GetHashCode());
            Debug.LogFormat("IInterfaceB：{0}", container.Resolve<IInterfaceB>().GetHashCode());
            Debug.LogFormat("ClassD：{0}", container.Resolve<ClassD>().GetHashCode());
        }
        interface IInterfaceA { }
        interface IInterfaceB { }
        class ClassD : IInterfaceA, IInterfaceB { }
    }
````

















- **DI**：***Dependency Injection***--**依赖注入**
- **IOC**：***Invertion Of Control***--**控制反转**



[(Github)modesttree/Zenject](https://github.com/modesttree/Zenject)

