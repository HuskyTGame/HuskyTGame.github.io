---
layout: article
title:  "2019-11-09-Zenject学习笔记"
categories: framework
image:
    teaser: /in-post/framework/2019-11-09-Zenject学习笔记/DefaultImg.jpg
---

# 目录

[TOC]

## 一、快速入门

一个最简单的依赖注入例子：

- Step1：在*Hierarchy*中通过"*鼠标右键--Zenject--Scene Context*"创建***SceneContext***场景上下文。

- Step2：通过"*鼠标右键--Zenject--Mono Installer*"创建***Mono Installer***并命名为*QuickStartInstaller*。

- Step3：在SceneContext上挂载*QuickStartInstaller*脚本，并在*Scene Context*组件中添加*Mono Installer*，然后将自身拖拽进去。如下图所示：

  ![picture0](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot000.png)

- Step4：在场景中创建空物体*HelloWorldExample*，并创建同名脚本并拖拽至该物体上。

- Step5：编写脚本：

  ````csharp
      public class QuickStartInstaller : MonoInstaller
      {
          public override void InstallBindings()
          {
              //使用容器Container绑定BluetoothService
              //并使其作为单例
              Container.Bind<BluetoothService>()
                  .AsSingle();
          }
          public class BluetoothService
          {
              public void Connect()
              {
                  Debug.Log("Examples--1.QuickStart--" + "蓝牙连接成功");
              }
          }
      }
  ````
  
````csharp
      public class HelloWorldExample : MonoBehaviour
      {
          //注入
          [Inject] private QuickStartInstaller.BluetoothService mBluetoothService;
          private void Start()
          {
              mBluetoothService.Connect();
          }
      }
````

*CTRL+SHIFT+R*运行后，控制台打印输出：``Examples--1.QuickStart--蓝牙连接成功``

## 二、基本使用

### 1.依赖注入

依赖注入：给当前脚本提供所需对象的实例，所需要的对象的实例需要通过``[Inject]``属性进行标记。

提供这些对象的操作，叫做注入操作。

**Zenject**的注入模式有4种：

- Constructor Injection：构造函数注入
- Field Injection：成员变量（域）注入
- Property Injection：属性器注入
- Method Injection：方法注入

#### （1）Constructor Injection（构造函数注入）

- 解释：通过构造方法传递实例
- 工作原理：根据构造方法的参数类型自动申请实例。（参数可以有多个）

步骤Step1~4与*快速入门*中的类似，仅修改相关名称。

Step5：编写脚本：

````csharp
    public class ConstructorInjectionInstaller : MonoInstaller
    {
        public override void InstallBindings()
        {
            Container.Bind<BluetoothService>()
                .AsSingle();
        }
        public class BluetoothService
        {
            public void Connect()
            {
                Debug.Log("Examples--2.ConstructorInjection构造函数注入--" + "蓝牙连接成功");
            }
        }
    }
````

**注意：**

- MonoBehaviour的对象创建过程由Unity引擎决定，所以无法在脚本的构造函数中进行依赖注入，而是使用名为*Constructor*的函数进行构造函数注入。
- *Constructor*函数上需要进行*Inject Attribute*注入属性标记：``[Inject]``。
- 函数名称不一定为*Constructor*，在脚本中，构造函数注入本质上是***Method Inject（方法注入）***。

````csharp
    public class ConstructorInjectionExample : MonoBehaviour
    {
        private ConstructorInjectionInstaller.BluetoothService mBluetoothService;
        //构造函数注入
        [Inject]
        void Constructor(ConstructorInjectionInstaller.BluetoothService bluetoothService)
        {
            mBluetoothService = bluetoothService;
        }
        private void Start()
        {
            mBluetoothService.Connect();
        }
    }
````

运行后控制台打印输出：``Examples--2.ConstructorInjection构造函数注入--蓝牙连接成功``。

#### （2）Field Injection（成员变量（域）注入）

````csharp
    public class FieldInjectionInstaller : MonoInstaller
    {
        public override void InstallBindings()
        {
            Container.Bind<BluetoothService>()
                .AsSingle();
        }
        public class BluetoothService
        {
            public void Connect()
            {
                Debug.Log("Examples--3.FieldInjection成员变量（域）注入--" + "蓝牙连接成功");
            }
        }
    }
````

**原理**：遍历通过*Inject Attribute*标记的成员变量，进行赋值。

````csharp
    public class FieldInjectionExample : MonoBehaviour
    {
        //成员变量（域）注入
        [Inject] private FieldInjectionInstaller.BluetoothService mBluetoothService;
        private void Start()
        {
            mBluetoothService.Connect();
        }
    }
````

运行后控制台打印输出：``Examples--3.FieldInjection成员变量（域）注入--蓝牙连接成功``。

#### （3）PropertyInjection（属性器注入）

````csharp
    public class PropertyInjectionInstaller : MonoInstaller
    {
        public override void InstallBindings()
        {
            Container.Bind<ResLoader>()
                .AsSingle();
        }
        public class ResLoader
        {
            public T Load<T>(string name) where T : Object
            {
                Debug.Log("Examples--4.PropertyInjection属性器注入--" + typeof(T) + name);
                return default(T);
            }
        }
    }
````

**原理**：遍历通过*Inject Attribute*标记的属性器，调用``SetProperty``方法进行赋值。

````csharp
    public class PropertyInjectionExample : MonoBehaviour
    {
        //属性器注入
        [Inject]
        public PropertyInjectionInstaller.ResLoader ResLoader { get; private set; }
        private void Start()
        {
            ResLoader.Load<GameObject>("TestGO");
        }
    }
````

运行后控制台打印输出：``Examples--4.PropertyInjection属性器注入--UnityEngine.GameObjectTestGO``。

#### （4）Method Injection（方法注入）

````csharp
    public class MethodInjectionInstaller : MonoInstaller
    {
        public override void InstallBindings()
        {
            Container.Bind<ResLoader>()
                .AsSingle();
        }
    }
    public class ResLoader
    {
        public T Load<T>(string name) where T : Object
        {
            Debug.Log("Examples--5.MethodInjection方法注入--" + typeof(T) + name);
            return default(T);
        }
    }
````

**原理**：遍历标记*Inject Attribute*的方法，并遍历方法中的参数，为参数设置实例。（MonoBehaviour中的构造函数注入其实用的就是方法注入）

````csharp
    public class MethodInjectionExample : MonoBehaviour
    {
        private ResLoader mResLoader1;
        private ResLoader mResLoader2;
        //方法注入
        [Inject]
        private void Method(ResLoader resLoader1, ResLoader resLoader2)
        {
            mResLoader1 = resLoader1;
            mResLoader2 = resLoader2;
        }
        private void Start()
        {
            mResLoader1.Load<GameObject>("1号");
            mResLoader1.Load<GameObject>("2号");
            Debug.Log(mResLoader1.GetHashCode());
            Debug.Log(mResLoader2.GetHashCode());
        }
    }
````

运行后控制台打印输出：``Examples--5.MethodInjection方法注入--UnityEngine.GameObject1号``；

``Examples--5.MethodInjection方法注入--UnityEngine.GameObject2号``；

``-630497024``；``-630497024``。因为``ResLoader``是单例，所以其HashCode相同。

#### （5）依赖注入总结

- ***Zenject***中依赖注入模式：（4种）

  Constructor Injection**构造函数注入**：在MonoBehaviour中本质上就是方法注入

  Filed Injection**成员变量（域）注入**

  Property Injection**属性器注入**

  Method Injection**方法注入**

- **推荐使用**构造函数注入（.Net Core只支持构造函数注入）

### 2.绑定

绑定最核心的功能就是向Container注册类型。

相关概念：

- Container--容器
- Bind--绑定方法
- ResLoader--类型

#### （1）DiContainer的使用

DiContainer：*Dependency Injection Container*--依赖注入的容器。

DiContainer的职责：管理绑定，管理依赖关系。

包含三个API：

- ``Bind<XXX>().To(YYY).AsZZZ()``：绑定。（``AsZZZ()``为Scope作用域）
- ``Resolve<XXX>()``：解析，作用是获取实例。
- ``Inject<XXX>()``：注入

##### （a）Resolve解析：在Container中寻找指定对象实例，若不存在则创建实例并返回。

````csharp
    public class DiContainerExample : MonoBehaviour
    {
        private void Start()
        {
            //创建Container进行绑定操作
            var container = new DiContainer();
            container.Bind<ResLoader>()
                .AsSingle();
            //Resolve解析：
            //先在Container中寻找是否有ResLoader实例，如果没有就创建并返回。
            ResLoader resLoader = container.Resolve<ResLoader>();
            resLoader.Load<GameObject>("PrefabA");
        }
    }
````

##### （b）Inject注入：遍历当前类，将标记有Inject Attribute的通过Resolve获取实例。

````csharp
    public class DiContainerInjectExample : MonoBehaviour
    {
        [Inject] private ResLoader mResLoader;
        private void Start()
        {
            var container = new DiContainer();
            container.Bind<ResLoader>()
                .AsSingle();
            //Inject包含两步操作：
            //1.遍历当前类
            //2.将标记有Inject Attribute的通过Resolve获取实例。
            //Resolve解析类型：查找实例并返回，若不存在则创建。
            container.Inject(this);
            mResLoader.Load<GameObject>("PrefabB");
        }
    }
````

##### （c）BindTo操作：约定类型与结果类型绑定

``Bind<ContractType>().To<ResultType>()``：

- ContractType：约定类型（类型不限，一般用接口）
- ResultType：结果类型（**Result is ContractType**）
- 根据约定类型解析出结果类型。

一个约定类型绑定一个结果类型：

````csharp
    public class BindToExample : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            //将约定类型与结果类型进行绑定
            container.Bind<IBluetoothService>()
                .To<BluetoothService>()
                .AsSingle();
            //约定类型进行解析（查找），返回结果类型实例。
            var bluetoothService = container.Resolve<IBluetoothService>();
            bluetoothService.Connect();
        }
        interface IBluetoothService
        {
            void Connect();
        }
        public class BluetoothService : IBluetoothService
        {
            public void Connect()
            {
                Debug.Log("蓝牙连接成功");
            }
        }
    }
````

``Bind(params Type[] contractTypes).To<ResultType>()``

多个约定类型绑定一个结果类型：

````csharp
    public class BindToExample2 : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            container.Bind<IClassA>()
                .To<ClassA>()
                .AsTransient();
            container.Bind<ClassABase>()
                .To<ClassA>()
                .AsTransient();
            container.Bind<ClassA>()
                .To<ClassA>()
                .AsTransient();
            //绑定多个类型的简化方式：
            container.Bind(typeof(IClassA), typeof(ClassABase), typeof(ClassA))
                .To<ClassA>()
                .AsSingle();
            Debug.Log(container.Resolve<IClassA>().GetType());
            Debug.Log(container.Resolve<ClassABase>().GetType());
            Debug.Log(container.Resolve<ClassA>().GetType());
        }
        interface IClassA { }
        public abstract class ClassABase : IClassA { }
        public class ClassA : ClassABase { }
    }
````

##### （d）Scope作用域：AsSingle/AsTransient/AsCached

![picture1](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot001.png)

###### AsSingle：以单例形式存在

不论Container容器解析多少次都为同一个对象。

测试脚本：

````csharp
    public class AsSingleExample : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            container.Bind<ResLoader>()
                .AsSingle();
            //单例哈希值相同
            Debug.Log(container.Resolve<ResLoader>().GetHashCode());
            Debug.Log(container.Resolve<ResLoader>().GetHashCode());
        }
    }
````

运行结果：（哈希值相同=>每次解析返回相同的对象）

![picture2](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot002.png)

###### AsTransient：每次解析时返回新的实例

Transient意为短暂的。

测试代码：

````csharp
    public class AsTransientExample : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            container.Bind<ResLoader>()
                .AsTransient();
            //Transient每次解析获取不同实例，哈希值不相同
            Debug.Log(container.Resolve<ResLoader>().GetHashCode());
            Debug.Log(container.Resolve<ResLoader>().GetHashCode());
        }
    }
````

运行结果：（哈希值不同=>每次解析返回对象不同的实例）

![picture3](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot003.png)

###### AsCached：为每个约定类型创建一个单例

Cached意为缓存。

AsCached：约定类型第一次解析时，创建一个新的实例。约定类型再次进行解析时，返回首次解析时创建的实例。（为每个约定类型创建一个单例实例）

测试代码：

````csharp
    public class AsCachedExample : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            //AsCached：
            //约定类型第一次解析时，创建一个新的实例
            //约定类型再次进行解析时，返回首次解析时创建的实例
            //为每个约定类型创建一个单例实例
            container.Bind<IClassB>()
                .To<ClassB>()
                .AsCached();
            container.Bind<ClassBBase>()
                .To<ClassB>()
                .AsCached();
            container.Bind<ClassB>()
                .To<ClassB>()
                .AsCached();
            //相同约定类型为一组
            //每一组的哈希值相同
            Debug.LogFormat("IClassB：{0}", container.Resolve<IClassB>().GetHashCode());
            Debug.LogFormat("IClassB：{0}", container.Resolve<IClassB>().GetHashCode());
            Debug.LogFormat("ClassBBase：{0}", container.Resolve<ClassBBase>().GetHashCode());
            Debug.LogFormat("ClassBBase：{0}", container.Resolve<ClassBBase>().GetHashCode());
            Debug.LogFormat("ClassB：{0}", container.Resolve<ClassB>().GetHashCode());
            Debug.LogFormat("ClassB：{0}", container.Resolve<ClassB>().GetHashCode());
        }
        interface IClassB { }
        abstract class ClassBBase : IClassB { }
        class ClassB : ClassBBase { }
    }
````

运行结果：（每一组的哈希值相同=>AsCached为每个约定类型创建一个单例）

![picture4](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot004.png)

###### Scope作用域代码总结

- AsSingle：以单例形式存在，不论解析多少次都为同一个对象。
- AsTransient：每次解析时返回新的实例。
- AsCached：约定类型第一次解析时，创建一个新的实例。约定类型再次进行解析时，返回首次解析时创建的实例。（为每个约定类型创建一个单例实例）。

##### （e）自动绑定接口

###### 自动绑定接口``BindInterfacesTo<ClassC>()``

将目标类型ClassC所有的接口作为约定类型与ClassC进行绑定

**注意**：只能是**接口**，抽象类和普通类均不行。

测试代码：

````csharp
    public class BindInterfacesToExample : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            //自动将ClassC所有接口与ClassC进行绑定
            container.BindInterfacesTo<ClassC>()
                .AsSingle();
            Debug.LogFormat("IInterfaceA：{0}", container.Resolve<IInterfaceA>().GetHashCode());
            Debug.LogFormat("IInterfaceB：{0}", container.Resolve<IInterfaceB>().GetHashCode());
        }
        interface IInterfaceA { }
        interface IInterfaceB { }
        class ClassC : IInterfaceA, IInterfaceB { }
    }
````

###### 自动绑定接口和自身``BindInterfacesAndSelfTo<ClassC>()``

将目标类型ClassC所有的接口和自身作为约定类型与ClassC进行绑定。（不能为抽象类）

测试代码：

````csharp
    public class BindInterfacesAndSelfToExample : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            //自动将ClassD所有接口和自身与ClassD进行绑定
            container.BindInterfacesAndSelfTo<ClassD>()
                .AsSingle();
            Debug.LogFormat("IInterfaceA：{0}", container.Resolve<IInterfaceA>().GetHashCode());
            Debug.LogFormat("IInterfaceB：{0}", container.Resolve<IInterfaceB>().GetHashCode());
            Debug.LogFormat("ClassD：{0}", container.Resolve<ClassD>().GetHashCode());
        }
        interface IInterfaceA { }
        interface IInterfaceB { }
        class ClassD : IInterfaceA, IInterfaceB { }
    }
````

##### （f）绑定实例

- ``Bind<XXX>().FromInstance(new XXX())``绑定实例
- ``BindInstance(new XXX())``绑定实例（简便方法）
- ``BindInstances(new XXX(),new YYY(),new ZZZ())``一次性绑定多个实例

将实例与约定类型绑定，之后每次解析约定类型时均返回同一实例。

测试代码：

````csharp
    public class BindInstanceExample : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            container.Bind<A>().FromInstance(new A());
            container.BindInstance(new B());
            container.BindInstances(new C(), new D(), new E());
            Debug.LogFormat("A：{0}", container.Resolve<A>().GetHashCode());
            Debug.LogFormat("A：{0}", container.Resolve<A>().GetHashCode());
            Debug.LogFormat("B：{0}", container.Resolve<B>().GetHashCode());
            Debug.LogFormat("B：{0}", container.Resolve<B>().GetHashCode());
            Debug.LogFormat("C：{0}", container.Resolve<C>().GetHashCode());
            Debug.LogFormat("D：{0}", container.Resolve<D>().GetHashCode());
            Debug.LogFormat("E：{0}", container.Resolve<E>().GetHashCode());
        }
        class A { }
        class B { }
        class C { }
        class D { }
        class E { }
    }
````

运行结果：

![picture5](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot005.png)

##### （g）绑定原生类型

可以绑定CSharp自带的原生类型。

测试代码：

````csharp
    public class BindPrimitiveTypeExample : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            container.Bind<int>().FromInstance(25);
            container.BindInstance("唐韡");
            Debug.LogFormat("int：{0}", container.Resolve<int>());
            Debug.LogFormat("string：{0}", container.Resolve<string>());
        }
    }
````

运行结果：

![picture6](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot006.png)

##### （h）``BindFromMethod``从方法中绑定（实例：方法的返回值）

可以从方法中绑定实例=>给绑定实例的过程增加逻辑

测试代码：

````csharp
    public class BindFromMethodExample : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            container.Bind<int>().FromMethod(GetRandomNumber);
            container.Bind<string>().FromMethod(() => "HelloWorld");
            Debug.LogFormat("int：{0}", container.Resolve<int>());
            Debug.LogFormat("int：{0}", container.Resolve<int>());
            Debug.LogFormat("int：{0}", container.Resolve<int>());
            Debug.LogFormat("string：{0}", container.Resolve<string>());
            Debug.LogFormat("string：{0}", container.Resolve<string>());
        }
        int GetRandomNumber()
        {
            return Random.Range(1, 10);
        }
    }
````

运行结果：

![picture7](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot007.png)

##### （I）``Bind<XXX>().FromFactory<XXXXX>()``绑定简单工厂

从工厂中绑定实例=>工厂生产的实例与约定类型进行绑定

测试代码：

````csharp
    public class BindFromFactoryExample : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            container.Bind<int>().FromFactory<RandomNumber>();
            Debug.LogFormat("int：{0}", container.Resolve<int>());
            Debug.LogFormat("int：{0}", container.Resolve<int>());
            Debug.LogFormat("int：{0}", container.Resolve<int>());
        }
        class RandomNumber : IFactory<int>
        {
            public int Create()
            {
                return Random.Range(1, 10);
            }
        }
    }
````

运行结果：

![picture8](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot008.png)

### 3.安装器Installer

安装器的作用是使一组绑定操作可以复用。

- 一般的Installer
- MonoInstaller：需要SceneContext
- ScriptableObjectInstaller：需要SceneContext，常用于绑定配置文件

#### （1）一般的Installer

测试代码：

````csharp
    public class InstallerExample : MonoBehaviour
    {
        private void Start()
        {
            var container = new DiContainer();
            //安装器在安装的过程中会执行InstallBindings方法
            //进行一系列绑定操作（本例中进行了两次绑定操作）
            //使用安装器进行绑定，可以将一组绑定操作复用。
            SubSystemInstaller.Install(container);//为Installer提供Container
            container.Resolve<MyTestClassA>().Test();
            container.Resolve<MyTestClassB>().Test();
        }
        class SubSystemInstaller : Installer<SubSystemInstaller>
        {
            public override void InstallBindings()
            {
                Container.Bind<MyTestClassA>()
                    .AsSingle();
                Container.Bind<MyTestClassB>()
                    .AsSingle();
            }
        }
    }
    public class MyTestClassA
    {
        public void Test()
        {
            Debug.Log(GetType());
        }
    }
    public class MyTestClassB
    {
        public void Test()
        {
            Debug.Log(GetType());
        }
    }
````

运行结果：

![picture9](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot009.png)

#### （2）MonoInstaller

- Step1：在*Hierarchy*中创建**SceneContext**（环境上下文，类似于一个组装器）

- Step2：在*Project*中通过"***鼠标右键--Create--Zenject--Mono Installer***"创建**MonoInstaller**脚本，取名为**SubSystemMonoInstaller**将脚本挂载到**SceneContext**上，并给**SceneContext**组件添加**Mono Installers**，最后将自身赋值进去，如下图：

  ![picture10](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot010.png)

- Step3：编辑**SubSystemMonoInstaller**脚本：（在其中可以进行一系列绑定操作）

  ````csharp
      public class SubSystemMonoInstaller : MonoInstaller
      {
          public override void InstallBindings()
          {
              Container.Bind<MyTestClassA>()
                  .AsSingle();
              Container.Bind<MyTestClassB>()
                  .AsSingle();
          }
      }
  ````

- Step4：创建空物体，取名为**MonoInstallerExample**，并创建同名脚本，将脚本挂载在该物体上，然后编辑脚本：

  ````csharp
      public class MonoInstallerExample : MonoBehaviour
      {
          [Inject] private MyTestClassA mMyTestClassA;
          [Inject] private MyTestClassB mMyTestClassB;
          private void Start()
          {
              mMyTestClassA.Test();
              mMyTestClassB.Test();
          }
      }
  ````

  MonoInstaller会自动完成绑定，然后在测试脚本中，会通过*Field Injection*成员变量（域）注入实例。

  运行结果：

  ![picture11](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot011.png)

#### （3）Scriptable Object Installer

一般用于绑定配置文件，使用流程如下：

- Step1：同上创建**SceneContext**（环境上下文）

- Step2：在*Project*中通过"***鼠标右键--Create--Zenject--Scriptable Object Installer***"创建脚本，并命名为**ConfigInstaller**，编辑脚本：

  ``PlayerSetting``为玩家配置的类，需要打上序列化标签。可以通过配置加载相关资源。

  ````csharp
      [CreateAssetMenu(fileName = "ConfigInstaller", menuName = "Installers/ConfigInstaller")]
      public class ConfigInstaller : ScriptableObjectInstaller<ConfigInstaller>
      {
          public PlayerSetting Setting;
          public override void InstallBindings()
          {
              //Container.Bind<PlayerSetting>().FromInstance(Setting);
              Container.BindInstance(Setting);
          }
          [System.Serializable]
          public class PlayerSetting
          {
              public int ID = 1001;
              public GameObject Prefab;
              public Sprite Icon;
          }
      }
  ````

- Step3：在*Project*中通过"***鼠标右键--Create--Installers--ConfigInstaller***"创建配置文件。

- Step4：将**ConfigInstaller**配置文件拖拽到**SceneContext**上，如下图：

  ![picture12](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot012.png)

- Step5：创建空物体，取名为**ScriptableObjectInstallerExample**，并创建同名脚本，将脚本挂载在该物体上，然后编辑脚本：

  ````csharp
      public class ScriptableObjectInstallerExample : MonoBehaviour
      {
          [Inject] private ConfigInstaller.PlayerSetting mPlayerSetting;
          private void Start()
          {
              Debug.LogFormat("PlayerID：{0}", mPlayerSetting.ID);
          }
      }
  ````

  ConfigInstaller会自动完成绑定，然后在测试脚本中，会通过*Field Injection*成员变量（域）注入实例。

  运行结果：

  ![picture13](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot013.png)

### 4.上下文Context

- *Context*负责管理/组装*Installer*和*Container*
- *Installer*进行绑定操作需要*Container*，这个*Container*由*Context*提供。
- *Context*有四种：
  - *Scene Context*：场景上下文
  - *GameObject Context*：
  - *Decorator Context*：装饰器上下文
  - *Project Context*：

#### （1）*Scene Context*场景上下文

- 每个场景的入口
- 第一个执行（如果隐藏则不执行，直到激活时才执行）
- 初始化场景中所有的依赖（注入所有依赖，即使被隐藏也会被注入依赖）

基础的使用方法同**MonoInstaller**。

### 5.动态注入

*Scene Context*会在场景运行第一时间对场景内的物体进行一次依赖注入，当运行的时候，如果有新的需要注入的物体被加载出来的时候需要进行动态注入。

动态注入：需要在被注入Prefab上添加脚本***Zen Auto Injecter***

**注意**：需要动态注入的对象初始运行时不能出现在场景中，否则会报***重复注入的***错误。

![picture14](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot014.png)

### 6.动态绑定

使用方法：

- 给需要动态绑定的对象添加***Zenject Binding***脚本，并给其*Components*赋值，然后设置*Bind Type*，如下图：

  ![picture15](https://huskytgame.github.io/images/in-post/framework/2019-11-09-Zenject学习笔记/ScreenShot015.png)

  之后此对象不需要*Installer*也会自动完成绑定。（场景中存在*Scene Context*）


## 三、官方示例与知识点补充













- **DI**：***Dependency Injection***--**依赖注入**
- **IOC**：***Invertion Of Control***--**控制反转**



[(Github)modesttree/Zenject](https://github.com/modesttree/Zenject)

