---
layout: article
title:  "UniRx学习笔记_中"
categories: framework
image:
    teaser: /in-post/framework/2019-12-24-UniRx学习笔记_中/DefaultImg.jpg
---

# 目录

[TOC]

## 一、Rx简介

### 1.Rx（***Reactive Extensions***）简介

- **微软**：“Rx 是一个函数库，让开发者可以利用可观察序列和 LINQ 风格查询操作符来编写异步和基于事件的程序，使用 Rx，开发者可以用 Observables 表示异步数据流，用 LINQ 操作符查询异步数
  据流， 用 Schedulers 参数化异步数据流的并发处理。”

  Rx 可以这样定义：***Rx = Observables + LINQ +Schedulers***。

- **ReactiveX.io(官方)** ：“Rx 是一个使用可观察数据流进行异步编程的编程接口。”

  ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。

### 2.Rx历史

ReactiveX 是 Reactive Extensions 的缩写，一般简写为 Rx。最初是 LINQ 的一个扩展，由微软的架构师 Erik Meijer 领导的团队开发，在 2012 年 11 月开源，Rx 是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流。

Rx 库支持 .NET、JavaScript 和 C++。Rx 近几年越来越流行了，现在已经支持几乎全部的流行编程语言了，Rx 的大部分语言库由 ReactiveX 这个组织负责维护，比较流行的有 RxJava/RxJS/Rx.NET，而 Unity 的版本，就是 UniRx。

## 二、Linq与UniRx操作符

### 1.**Common**常用

#### （1）***Where***

**① 说明**

***Where***：Filter过滤作用

代码位置：Observable.cs

**② Linq链式**

````csharp
            students.Where(student => student.Age > 13)
                          .ToList()
                          .ForEach(stu =>
                          {
                              Debug.Log(stu.Name);
                          });
````

**③ Linq查询表达式**

````csharp
            (from student in students where student.Age > 13 select student)
                .ToList()
                .ForEach(stu =>
                {
                    Debug.Log(stu.Name);
                });
````

**④ UniRx链式**

````csharp
            Observable.EveryUpdate()
                              .Where(_ => Input.GetMouseButton(0))
                              .Subscribe(_ => Debug.Log("点击鼠标左键"))
                              .AddTo(this);
````

**⑤ UniRx查询表达式**

````csharp
            (from updateEvent in Observable.EveryUpdate() where Input.GetMouseButton(0) select updateEvent)
                .Subscribe(_ => Debug.Log("点击鼠标左键"))
                .AddTo(this);
````

#### （2）***Select***

**① 说明**

***Select***：Map映射作用，返回一个结果。

代码位置：Observable.cs

**② Linq链式**

````csharp
            students.Where(student => student.Age > 13)
                          .Select(student => student.Name)
                          .ToList()
                          .ForEach(student =>
                          {
                              Debug.Log(student);
                          });
````

**③ Linq查询表达式**

````csharp
            (from student in students where student.Age > 13 select student.Name)
                .ToList()
                .ForEach(student =>
                {
                    Debug.Log(student);
                });
````

**④ UniRx链式**

````csharp
            Observable.EveryUpdate()
                              .Where(_ => Input.GetMouseButton(0))
                              .Select(_ => "点击鼠标左键")
                              .Subscribe(eventName => Debug.Log(eventName))
                              .AddTo(this);
````

**⑤ UniRx查询表达式**

````csharp
            (from updateEvent in Observable.EveryUpdate() where Input.GetMouseButton(0) select "点击鼠标左键")
                .Subscribe(eventName => Debug.Log(eventName))
                .AddTo(this);
````

#### （3）***Distinct***

**① 说明**

***Distinct***：过滤数据集中的重复的部分，保证不同数据都有且仅有一个。

代码位置：Observable.cs

**② Linq链式**

````csharp
            msgs.Distinct()
                    .ToList()
                    .ForEach(msg =>
                    {
                        Debug.Log(msg);
                    });
````

**③ Linq查询表达式**

````csharp
            (from msg in msgs select msg)
                 .Distinct()
                 .ToList()
                 .ForEach(msg =>
                 {
                     Debug.Log(msg);
                 });
````

**④ UniRx链式**

````csharp
            var leftMouseClickedStream = Observable.EveryUpdate()
                                                                .Where(_ => Input.GetMouseButtonDown(0))
                                                                .Select(_ => "点击鼠标左键");
            var rightMouseClickedStream = Observable.EveryUpdate()
                                                                .Where(_ => Input.GetMouseButtonDown(1))
                                                                .Select(_ => "点击鼠标右键");
            Observable.Merge(leftMouseClickedStream, rightMouseClickedStream)
                              .Distinct()
                              .Subscribe(eventName =>
                              {
                                  Debug.Log(eventName);
                              });
````

#### （4）***SelectMany***

**① 说明**

***SelectMany***：将序列的每个元素投影到 IEnumerable<T> 并将结果序列合并为一个序列。

在UniRx中主要用于完成**协程顺序执行**的功能。

代码位置：Observable.cs

**② Linq链式**

````csharp
            students.SelectMany(student =>
            {
                return student.Name + "：" + student.Age;
            })
            .ToList()
            .ForEach(singleChar => Debug.Log(singleChar));
````

运行结果：

![picture0](https://huskytgame.github.io/images/in-post/framework/2019-12-24-UniRx学习笔记_中/ScreenShot000.png)

**③ UniRx链式**

````csharp
            //Coroutine顺序执行
            IEnumerator A()
            {
                yield return new WaitForSeconds(1f);
                Debug.Log("A");
            }
            IEnumerator B()
            {
                yield return new WaitForSeconds(1f);
                Debug.Log("B");
            }
            IEnumerator C()
            {
                yield return new WaitForSeconds(1f);
                Debug.Log("C");
            }
            var aStream = Observable.FromCoroutine(A);
            var bStream = Observable.FromCoroutine(B);
            var cStream = Observable.FromCoroutine(C);
            aStream.SelectMany(bStream.SelectMany(cStream))
                         .Subscribe(_ => Debug.Log("End"));
````

运行结果：

![picture1](https://huskytgame.github.io/images/in-post/framework/2019-12-24-UniRx学习笔记_中/ScreenShot001.png)

#### （5）***ToArray***

**① 说明**

***ToArray***：从 IEnumerable<T> 中创建数组。

**② Linq链式**

````csharp
var names = students.Select(student => student.Name)
    			   .ToArray();
Array.ForEach(names, name => Debug.Log(name));
````

**③ UniRx链式**

````csharp
Subject<float> subject = new Subject<float>();
subject.TakeLast(TimeSpan.FromSeconds(1.0f))
    .ToArray()
    .Subscribe(times =>
               {
                   Array.ForEach(times, time => Debug.LogFormat("点击时间：{0}", time));
               });

Observable.EveryUpdate()
    .Where(_ => Input.GetMouseButtonDown(0))
    .Subscribe(_ => subject.OnNext(Time.time));
Observable.Timer(TimeSpan.FromSeconds(2.0f))
    .Subscribe(_ => subject.OnCompleted());
````

#### （6）***ToList***

**① 说明**

***ToList***：从 IEnumerable<T> 创建一个 List<T>。

**② Linq链式**

````csharp
students.Select(student => student.Name)
    .ToList()
    .ForEach(name => Debug.Log(name));
````

**③ UniRx链式**

````csharp
Subject<float> subject = new Subject<float>();
subject.ToList()
    .Subscribe(times =>
               {
                   foreach (float time in times)
                   {
                       Debug.LogFormat("时间：{0}", time);
                   }
               });
Observable.Timer(TimeSpan.FromSeconds(1.0f))
    .Repeat()
    .Take(3)
    .Subscribe(_ => subject.OnNext(Time.time), () => subject.OnCompleted());
````

运行结果：

![picture12](https://huskytgame.github.io/images/in-post/framework/2019-12-24-UniRx学习笔记_中/ScreenShot012.png)

### 2.**Paging**分页

#### （1）***First***

**① 说明**

***First***：（有条件得）取数据链中的第一个数据。可以先进行一次条件过滤，再取过滤后的数据链中的第一个数据。

**② Linq链式**

````csharp
            Student stu1 = students.First(student => student.Age > 13);
            Debug.Log(stu1.Name);
````

**③ Linq查询表达式**

````csharp
            Student stu2 = (from student in students select student)
                                        .First(student => student.Age > 13);
            Debug.Log(stu2.Name);
````

**④ UniRx链式**

````csharp
            Observable.EveryUpdate()
                              .First(_ => Input.GetMouseButton(0))
                              .Subscribe(_ => Debug.Log("点击鼠标左键"))
                              .AddTo(this);
````

**⑤ UniRx查询表达式（测试无效）**

````csharp
            (from updateEvent in Observable.EveryUpdate() select "点击鼠标左键")
                .First()
                .Subscribe(eventName => Debug.Log(eventName))
                .AddTo(this);
````

#### （2）***Last***

**① 说明**

***Last***：（有条件得）取数据链中的最后一个数据。可以先进行一次条件过滤，再取过滤后的数据链中的最后一个数据。

**② Linq链式**

````csharp
            Student stu = students.Last(student => student.Age > 13);
            Debug.Log(stu.Name);
````

**③ UniRx链式**

````csharp
            IObservable<int> observable = Observable.Create<int>(observer =>
            {
                observer.OnNext(1);
                observer.OnNext(2);
                observer.OnNext(3);
                observer.OnCompleted();
                return Disposable.Create(() => Debug.Log("Dispose"));
            });
            observable.Last()
                      .Subscribe(value => Debug.Log(value));
````

运行结果：

![picture2](https://huskytgame.github.io/images/in-post/framework/2019-12-24-UniRx学习笔记_中/ScreenShot002.png)

#### （3）***Take***

**① 说明**

***Take***：从序列的开头返回指定数量的相邻元素。

使用 Take 操作符让你可以修改 Observable 的行为，只返回前面的N项数据，然后发射完成通知，忽略剩余的数据。

**② Linq链式**

````csharp
            List<Student> students = new List<Student>()
            {
                new Student{Name="张三",Age=15},
                new Student{Name="李四",Age=13},
                new Student{Name="王五",Age=16},
                new Student{Name="赵六",Age=12},
            };
            students.Take(2)
                          .ToList()
                          .ForEach(stu =>
                          {
                              Debug.Log(stu.Name);
                          });
````

运行结果：

![picture3](https://huskytgame.github.io/images/in-post/framework/2019-12-24-UniRx学习笔记_中/ScreenShot003.png)

**③ UniRx链式**

````csharp
            //获取前3次鼠标点击
            Observable.EveryUpdate()
                              .Where(_ => Input.GetMouseButtonDown(0))
                              .Take(3)
                              .Subscribe(_ => Debug.Log("点击鼠标左键"));
            //Take重载：
            //只响应前五秒：Take(TimeSpan.FromSeconds(5f))
````

#### （4）***Skip***

**① 说明**

***Skip***：跳过序列中指定数量的元素，然后返回剩余的元素。

**② Linq链式**

````csharp
List<int> grades = new List<int> { 89, 92, 45, 61, 77, 82, 76, 97, 41, 69 };

grades.OrderBy(grade => grade)
    .Skip(2)
    .ToList()
    .ForEach(grade => Debug.Log(grade));
````

**③ UniRx链式**

````csharp
//跳过前三次鼠标左键的点击事件
Observable.EveryUpdate()
		 .Where(_ => Input.GetMouseButtonDown(0))
		 .Skip(3)
		 .Subscribe(_ => Debug.Log("点击鼠标左键"));
//Skip重载：
//跳过前五秒：Skip(TimeSpan.FromSeconds(5f))
````

#### （5）***GroupBy***

**① 说明**

***GroupBy***：对序列中的元素进行分组。

**② Linq链式**

````csharp
List<Student> students = new List<Student>()
{
    new Student{Name="张三",Age=15},
    new Student{Name="李四",Age=14},
    new Student{Name="王五",Age=14},
    new Student{Name="赵六",Age=15},
    new Student{Name="钱七",Age=13},
    new Student{Name="孙八",Age=14},
};
//按照年龄分组
students.GroupBy(student => student.Age)
    .ToList()
    .ForEach(studentGroup =>
             {
                 studentGroup.ToList()
                     		.ForEach(student =>
                              {
                                  Debug.LogFormat("Group：{0}；Name：{1}；Age：{2}"
                                                  , studentGroup.Key, student.Name, student.Age);
                              });
             });
````

运行结果：

![picture6](https://huskytgame.github.io/images/in-post/framework/2019-12-24-UniRx学习笔记_中/ScreenShot006.png)

**③ Linq查询表达式**

````csharp
var group =
    from student in students
    group student by student.Age into studentGroup
    select studentGroup;
group.ToList()
     .ForEach(studentGroup =>
             {
                 studentGroup.ToList()
                     .ForEach(student =>
                              {
                                  Debug.LogFormat("Group：{0}；Name：{1}；Age：{2}"
                                                  , studentGroup.Key, student.Name, student.Age);
                              });
             });
````

**④ UniRx链式**

````csharp
            Subject<int> subject = new Subject<int>();

            subject.GroupBy(num => num % 2 == 0 ? "偶数" : "奇数")
                        .Subscribe(numberGroup =>
                        {
                            numberGroup.Subscribe(number =>
                            {
                                Debug.LogFormat("Group：{0}；Number：{1}", numberGroup.Key, number);
                            });
                        });

            subject.OnNext(1);
            subject.OnNext(2);
            subject.OnNext(3);
            subject.OnNext(4);
            subject.OnCompleted();//手动调用OnCompleted
            subject.OnNext(5);
````

运行结果：

![picture7](https://huskytgame.github.io/images/in-post/framework/2019-12-24-UniRx学习笔记_中/ScreenShot007.png)

#### （6）***TakeWhile***

**① 说明**

***TakeWhile***：如果指定的条件为 true，则返回序列中的元素；直到当指定条件为false的时候，跳过当前的以及剩余的元素。

**② Linq链式**

````csharp
List<string> colors = new List<string> { "red", "orange", "yellow", "green", "blue", "purple" };
//如果指定的条件为 true，则返回序列中的元素；直到当指定条件为false的时候，跳过当前的以及剩余的元素。
colors.TakeWhile(color => color != "yellow")
    .ToList()
    .ForEach(color => Debug.LogFormat("颜色：{0}", color));
````

运行结果：

![picture8](https://huskytgame.github.io/images/in-post/framework/2019-12-24-UniRx学习笔记_中/ScreenShot008.png)

**③ UniRx链式**

````csharp
//其中 times 表示 TakeWhile 的执行次数
Observable.EveryUpdate()
    .Where(_ => Input.GetMouseButton(0))
    .TakeWhile((_, times) => Input.GetMouseButtonUp(0) == false && times <= 25)
    .Subscribe(_ => Debug.Log("点击鼠标左键"));
````

#### （7）***SkipWhile***

**① 说明**

***SkipWhile***：如果指定的条件为 true，则跳过序列中的元素；直到当指定条件为false的时候，返回当前的以及剩余的元素。（和***TakeWhile***恰好相反）

**② Linq链式**

````csharp
List<int> grades = new List<int> { 45, 41, 92, 68, 77, 84, 62, 88, 98, 95, 23, 75, 81 };
grades.OrderByDescending(grade => grade)
    .SkipWhile(grade => grade >= 60)
    .ToList()
    .ForEach(grade => Debug.LogFormat("不及格的分数：{0}", grade));
````

运行结果：

![picture9](https://huskytgame.github.io/images/in-post/framework/2019-12-24-UniRx学习笔记_中/ScreenShot009.png)

**③ UniRx链式**

````csharp
Observable.EveryUpdate()
    .SkipWhile((_, times) => Input.GetMouseButtonDown(0) == false && times <= 100)
    .Subscribe(_ => Debug.Log("等待超时或鼠标左键按下"));
````

#### （8）***TakeLast***

**① 说明**

***TakeLast***：获取序列的最后几项。

***TakseLast***操作符是**.Net Core**提供的。

**② UniRx链式**

````csharp
Subject<float> subject = new Subject<float>();
//对subject最后1秒的事件流注册事件
subject.TakeLast(TimeSpan.FromSeconds(1.0f))
    .Subscribe(clickTime => Debug.LogFormat("当前点击时间：{0}", clickTime));

//每次点击鼠标左键时注册subject，并传入当前的点击时间
Observable.EveryUpdate()
    .Where(_ => Input.GetMouseButtonDown(0))
    .Subscribe(_ => subject.OnNext(Time.time));
//5秒后注册subject的结束事件
Observable.Timer(TimeSpan.FromSeconds(5.0f))
    .Subscribe(_ => subject.OnCompleted());
````

运行结果：

![picture11](https://huskytgame.github.io/images/in-post/framework/2019-12-24-UniRx学习笔记_中/ScreenShot011.png)

#### （9）***Single***

**① 说明**

***Single***：返回序列中的单个特定元素，与***First***非常类似，但是***Single***要确保其满足条件的元素在序列中只有一个。（若有多个则**报异常**）

**② Linq链式**

````csharp
List<string> colors = new List<string> { "red", "orange", "yellow", "green", "blue" };
Debug.Log(colors.Single(color => color.Length > 4));//报异常
````

**③ UniRx链式**

````csharp
Subject<int> subject = new Subject<int>();
subject.Where(number => number % 2 == 0)
    .Subscribe(number => Debug.Log(number));//报异常

subject.OnNext(1);
subject.OnNext(2);
subject.OnNext(3);
subject.OnNext(4);
subject.OnCompleted();
````

### 3.**Concatenate**联合

#### （1）***Merge***

**① 说明**

***Merge***：

**② Linq链式**

````csharp

````

**③ UniRx链式**

````csharp

````

#### （2）***WhenAll***

**① 说明**

***WhenAll***：判定Observable发射的所有数据是否都满足某个条件。

当所有OnComplete事件都完成时（非顺序执行），再执行WhenAll中注册的事件。

**② Linq链式**

````csharp
            List<int> ages = new List<int> { 5, 15, 25, 55, 100 };
            ages.All(age => age > 1);//true
            ages.All(age => age > 10);//false
````

**③ UniRx链式**

````csharp
            IEnumerator A()
            {
                yield return new WaitForSeconds(2f);
                Debug.Log("协程A执行完毕");
            }
            var aStream = Observable.FromCoroutine(A);
            var leftStream = Observable.EveryUpdate()
                .Where(_ => Input.GetMouseButtonDown(0))
                .Take(2)
                .Select(_ =>
                {
                    Debug.Log("点击鼠标左键");
                    return Unit.Default;
                });
            var rightStream = Observable.EveryUpdate()
                .Where(_ => Input.GetMouseButtonDown(1))
                .Take(3)
                .Select(_ =>
                {
                    Debug.Log("点击鼠标右键");
                    return Unit.Default;
                });
            Observable.WhenAll(aStream, leftStream, rightStream)
                              .Subscribe(_ => Debug.Log("All Completed"));
````

#### （3）***Concat***

**① 说明**

***Concat***：顺序连接数据。

**② Linq链式**

````csharp
            List<int> classA = new List<int> { 1, 2, 3 };
            List<int> classB = new List<int> { 4, 5, 6 };     
            //顺序输出1,2,3,4,5,6
            classA.Concat(classB)
                      .ToList()
                      .ForEach(value => Debug.Log(value));
````

**③ UniRx链式**

````csharp
            var aStream = Observable.EveryUpdate()
                .Where(_ => Input.GetMouseButtonDown(0))
                .Select(_ => "点击鼠标左键")
                .Take(2);
            var bStream = Observable.EveryUpdate()
                .Where(_ => Input.GetMouseButtonDown(1))
                .Select(_ => "点击鼠标右键")
                .Take(3);
            aStream.Concat(bStream)
                          .Subscribe(eventName => Debug.Log(eventName));
````

#### （4）***Zip***

**① 说明**

***Zip***：将指定函数应用于两个序列的对应元素，以生成结果序列。

**② Linq链式**

````csharp
List<int> nums = new List<int> { 1, 2, 3, 4 };
List<string> strs = new List<string> { "a", "b", "c" };
nums.Zip(strs, (first, second) => first + second)
    .ToList()
    .ForEach(_ => Debug.Log(_));
````

运行结果：

![picture10](https://huskytgame.github.io/images/in-post/framework/2019-12-24-UniRx学习笔记_中/ScreenShot010.png)

**③ UniRx链式**

````csharp
var leftStream = Observable.EveryUpdate().Where(_ => Input.GetMouseButtonDown(0));
var rightStream = Observable.EveryUpdate().Where(_ => Input.GetMouseButtonDown(1));
leftStream.Zip(rightStream, (l, r) => Unit.Default)
    .Subscribe(_ => Debug.Log("完成一对鼠标左右键点击"));
````

### 4.**Conversion**转化

#### （1）***OfType***

**① 说明**

***OfType***：筛选类型。

**② Linq链式**

````csharp
            List<object> objs = new List<object> { 1, 2, "3", 4, 5, "6", 7, 8 };
            //筛选出string类型
            objs.OfType<string>()
                   .ToList()
                   .ForEach(value => Debug.Log(value));
````

**③ UniRx链式**

```csharp
        public class Enemy { public string Name { get; set; } }
        public class Boss : Enemy { }
        public class Monster : Enemy { }

            Subject<Enemy> enemies = new Subject<Enemy>();
            enemies.OfType<Enemy, Boss>()
                         .Subscribe(boss => Debug.Log(boss.Name));

            enemies.OnNext(new Monster { Name = "黄速龙" });
            enemies.OnNext(new Monster { Name = "蓝速龙" });
            enemies.OnNext(new Boss { Name = "轰龙" });
            enemies.OnCompleted();//可手动调用OnCompleted
            enemies.OnNext(new Boss { Name = "电龙" });
```

运行结果：

![picture4](https://huskytgame.github.io/images/in-post/framework/2019-12-24-UniRx学习笔记_中/ScreenShot004.png)

#### （2）***Cast***

**① 说明**

***Cast***：将 IEnumerable 的元素**强制转换**为指定的类型。如果类型不可强制转化则报异常。

**② Linq链式**

````csharp
            List<object> objs = new List<object> { "1", "2", "3" };
            //将object强制转换为string
            objs.Cast<string>()
                   .ToList()
                   .ForEach(value => Debug.Log(value));
````

**③ UniRx链式**

````csharp
            Subject<object> subject = new Subject<object>();
            subject.Cast<object, string>()
                       .Subscribe(str =>
                       {
                           Debug.Log(str);
                       }, exception =>
                       {
                           Debug.Log("Has Exception");
                           Debug.LogException(exception);
                       });
            subject.OnNext("随意输入");
            subject.OnNext("无意义");
            subject.OnNext(25);
            subject.OnCompleted();
````

运行结果：

![picture5](https://huskytgame.github.io/images/in-post/framework/2019-12-24-UniRx学习笔记_中/ScreenShot005.png)

### 5.**Creation**创建

#### （1）***Start***

**① 说明**

***Start***：

**② Linq链式**

````csharp

````

**③ UniRx链式**

````csharp

````

#### （2）***Range***

**① 说明**

***Range***：生成指定范围内的整数的序列。

**② Linq链式**

````csharp
//输出4,9,16
Enumerable.Range(2, 3)
    .Select(num => num * num)
    .ToList()
    .ForEach(num => Debug.Log(num));
````

**③ UniRx链式**

````csharp
//输出4,9,16
Observable.Range(2, 3)
    .Select(num => num * num)
    .Subscribe(num => Debug.Log(num));
````

#### （3）***Repeat***

**① 说明**

***Repeat***：在生成序列中重复该值的次数。

在UniRx中***Repeat***表示重复，但不能指定重复次数，会不停重复下去。

**② Linq链式**

````csharp
Enumerable.Repeat("HuskyT", 3)
    .ToList()
    .ForEach(_ => Debug.Log(_));
````

**③ UniRx链式**

````csharp
Observable.Timer(TimeSpan.FromSeconds(1f))
    .Repeat()
    .Subscribe(_ => Debug.Log("过了一秒"));
````

#### （4）***Empty***

**① 说明**

***Empty***：返回具有指定类型参数的空 IEnumerable<T>。

**② Linq链式**

````csharp
List<int> list = Enumerable.Empty<int>().ToList();
Debug.Log(list.Count);//结果：0
````

**③ UniRx链式**

````csharp
//会立即执行OnCompleted事件
Observable.Empty<int>()
    .Subscribe(_ => { }, () => Debug.Log("Completed"));
````

### 6.**Aggregate**聚合

#### （1）***Aggregate***

**① 说明**

***Aggregate***：对序列应用累加器函数。 将指定的种子值用作累加器的初始值，并使用指定的函数选择结果值。

**② Linq链式**

````csharp
List<int> grades = new List<int> { 23, 45, 61, 67, 77, 88, 92 };
//求最小值
int minGrade = grades.Aggregate((min, next) => min > next ? next : min);
Debug.Log(minGrade);
````

**③ UniRx链式**

````csharp
Subject<int> subject = new Subject<int>();
//求最大值
subject.Aggregate((max, next) => max >= next ? max : next)
    .Subscribe(max => Debug.Log(max));
subject.OnNext(23);
subject.OnNext(45);
subject.OnNext(61);
subject.OnNext(92);
subject.OnCompleted();
````

## 三、Rx独有

### 1.**Common**常用

#### （1）***Merge***

**① 说明**

***Merge***：

**② Linq链式**

````csharp

````

**③ UniRx链式**

````csharp

````



### 2.**Paging**分页

#### （1）***Merge***

**① 说明**

***Merge***：

**② Linq链式**

````csharp

````

**③ UniRx链式**

````csharp

````



### 3.**Concatenate**联合

#### （1）***Merge***

**① 说明**

***Merge***：

**② Linq链式**

````csharp

````

**③ UniRx链式**

````csharp

````



### 4.**Conversion**转化

#### （1）***Merge***

**① 说明**

***Merge***：

**② Linq链式**

````csharp

````

**③ UniRx链式**

````csharp

````



### 5.**Creation**创建

#### （1）***Merge***

**① 说明**

***Merge***：

**② Linq链式**

````csharp

````

**③ UniRx链式**

````csharp

````



### 6.**Aggregate**聚合

#### （1）***Merge***

**① 说明**

***Merge***：

**② Linq链式**

````csharp

````

**③ UniRx链式**

````csharp

````





### 7.**Time**时间

#### （1）***Timer***

**① 说明**

***Timer***：

**② Linq链式**

````csharp

````

**③ UniRx链式**

````csharp

````

#### （2）***Interval***

**① 说明**

***Interval***：

**② Linq链式**

````csharp

````

**③ UniRx链式**

````csharp

````







### 8.**Unity**

#### （1）***Merge***

**① 说明**

***Merge***：

**② Linq链式**

````csharp

````

**③ UniRx链式**

````csharp

````





