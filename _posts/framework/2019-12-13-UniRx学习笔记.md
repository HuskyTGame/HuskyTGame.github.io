---
layout: article
title:  "UniRx学习笔记"
categories: framework
image:
    teaser: /in-post/framework/2019-12-13-UniRx学习笔记/DefaultImg.jpg
---

# 目录

[TOC]

## 一、概述

### 1.UniRx作用

**UniRx**：***Unity Reactive Extensions***——响应式扩展

- 简洁优雅得实现异步逻辑
- 优雅实现MVP/MVC模式
- 对UGUI/UnityAPI提供增强
- 提高编码效率

### 2.基本语法格式

``Observable.Timer().Subscribe().AddTo(继承自IDisposable接口的对象)``

其中：

- ``Observable``：可被观察的，UniRx中固定的开头
- ``Timer``：发布者，也被称作数据源/事件源
- ``Subscribe``：订阅者
- ``AddTo``：绑定销毁的生命周期

## 二、快速入门

### 1.计时器

#### （1）常规计时器

````csharp
    public class CommonTimerExample : MonoBehaviour
    {
        private float mStartTime;
        private void Start()
        {
            mStartTime = Time.time;
        }
        private void Update()
        {
            if (Time.time - mStartTime >= 3f)
            {
                Debug.Log("Do Something");
                mStartTime = float.MaxValue;
            }
        }
    }
````

#### （2）Unity协程下的计时器

````csharp
    public class CoroutineTimerExample : MonoBehaviour
    {
        private void Start()
        {
            StartCoroutine(TimeTask(3.0f, () =>
             {
                 Debug.Log("Do Something");
             }));
        }
        IEnumerator TimeTask(float time, Action callback)
        {
            yield return new WaitForSeconds(time);
            callback?.Invoke();
        }
    }
````

#### （3）UniRx实现计时器

``Observable.Timer(TimeSpan.FromSeconds(时间)).Subscribe(_={计时任务逻辑})``

````csharp
    public class UniRxTimerExample : MonoBehaviour
    {
        private void Start()
        {
            Observable.Timer(TimeSpan.FromSeconds(3.0f))
                .Subscribe(_ =>
                {
                    Debug.Log("Do Something");
                });
        }
    }
````

### 2.独立的Update

UniRx比较初级的使用：使用UniRx注册事件以避免在Update中增加逻辑。

``Observable.EveryUpdate().Subscribe(_=>{待注册的逻辑})``

````csharp
    public class UpdateExample : MonoBehaviour
    {
        enum ButtonState
        {
            None,
            Clicked,
        }
        private void Start()
        {
            bool mouseClicked = false;
            ButtonState buttonState = ButtonState.None;
            //使用UniRx注册事件以避免在Update中增加逻辑
            Observable.EveryUpdate()
                .Subscribe(_ =>
                {
                    if (Input.GetMouseButtonDown(0))
                    {
                        Debug.Log("鼠标左键点击");
                        mouseClicked = true;
                    }
                });
            Observable.EveryUpdate()
                .Subscribe(_ =>
                {
                    if (Input.GetMouseButtonDown(1))
                    {
                        Debug.Log("鼠标右键点击");
                        mouseClicked = true;
                    }
                });
            Observable.EveryUpdate()
                .Subscribe(_ =>
                {
                    if (mouseClicked && buttonState == ButtonState.None)
                    {
                        buttonState = ButtonState.Clicked;
                        Debug.Log("按钮点击状态切换为：" + buttonState);
                    }
                });
        }
    }
````

### 3.UniRx的API：``AddTo``

**AddTo**概述：

- 一个静态扩展关键字，对接口***IDisposable***进行了扩展；
- 只要实现了此接口，都可以使用AddTo；
- 当AddTo的目标销毁的时候，就会调用***IDisposable***的``OnDispose``方法。

**AddTo**作用：

- 将GameObject或MonoBehaviour销毁与UniRx绑定。
- 当GameObjec或MonoBehaviour被销毁的时候，UniRx的相关任务也会被销毁，防止产生空引用异常，增加UniRx使用的安全性。

代码：

````csharp
            Observable.Timer(TimeSpan.FromSeconds(2f))
                .Subscribe()
                .AddTo(this);//也可以是gameObject
````

当this脚本被销毁时，Timer同时被销毁，防止空引用异常。

### 4.操作符

#### （1）***Where***

作用：对数据源（发布者）进行过滤；位于发布者和订阅者之间。

````csharp
    public class WhereExample : MonoBehaviour
    {
        private void Start()
        {
            Observable.EveryUpdate()
                .Where(_ => Input.GetMouseButtonDown(0))
                .Subscribe(_ =>
                {
                    Debug.Log("鼠标左键点击");
                })
                .AddTo(this);
        }
    }
````

#### （2）***First***

作用：对数据源（发布者）进行过滤；获取满足***First***内部条件的数据源中的第一个数据；可替代***Where***。

````csharp
        private void Start()
        {
            Observable.EveryUpdate()//  数据源/事件源    发布者
                .First(_ => Input.GetMouseButtonDown(0))//  处理、组织、整理
                .Subscribe(_ => Debug.Log("第一次点击鼠标左键"))//  订阅者
                .AddTo(this);//  生命周期绑定
        }
````

### 5.对UGUI的支持

#### （1）**Button**

````csharp
            button.OnClickAsObservable()
                .First()
                .Subscribe(_ => Debug.Log("第一次点击按钮"));
````

#### （2）Toggle

````csharp
            toggle.OnValueChangedAsObservable()
                .Where(on => on)
                .Subscribe(_ => Debug.Log("开关为True"));
````

#### （3）Triggers——拖拽事件

````csharp
            image.OnBeginDragAsObservable()
                .Subscribe(_ => Debug.Log("Begin Drag"));
            image.OnDragAsObservable()
                .Subscribe(_ => Debug.Log("Dragging"));
            image.OnEndDragAsObservable()
                .Subscribe(_ => Debug.Log("End Drag"));
````

### 6.**ReactiveProperty**——响应式属性

很多时候，当某个变量的值改变时，内部或外部需要执行相关逻辑，通常此时会将变量用属性封装，然后使用委托或事件供内部或外部注册值改变时候的逻辑。

UniRx提供ReactiveProperty响应式属性，以减少实现上述需求的代码量。

````csharp
    public class ReactivePropertyExample : MonoBehaviour
    {
        //IntReactiveProperty：可序列化的响应式属性
        public IntReactiveProperty Age = new IntReactiveProperty(25);
        private void Start()
        {
            //注册的时候，会自动执行一次内部逻辑
            Age.Subscribe(age => Debug.Log("内部订阅Age改变时候需要执行的逻辑，此时Age：" + age));
            Age.Value = 26;
            new PersonA().Init(this);
        }
    }
    public class PersonA
    {
        public void Init(ReactivePropertyExample reactivePropertyExample)
        {
            //注册的时候，会自动执行一次内部逻辑
            reactivePropertyExample.Age.Subscribe(age => Debug.Log("外部订阅Age改变时候需要执行的逻辑，此时Age：" + age));
            reactivePropertyExample.Age.Value = 27;
        }
    }
````

运行结果：

![picture0](https://huskytgame.github.io/images/in-post/framework/2019-12-13-UniRx学习笔记/ScreenShot000.png)











