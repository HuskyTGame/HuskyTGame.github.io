---
layout: article
title:  "UniRx学习笔记"
categories: framework
image:
    teaser: /in-post/framework/2019-12-13-UniRx学习笔记/DefaultImg.jpg
---

# 目录

[TOC]

## 一、概述

### 1.UniRx作用

**UniRx**：***Unity Reactive Extensions***——响应式扩展

- 简洁优雅得实现异步逻辑
- 优雅实现MVP/MVC模式
- 对UGUI/UnityAPI提供增强
- 提高编码效率

## 二、快速入门

### 1.计时器

#### （1）常规计时器

````csharp
    public class CommonTimerExample : MonoBehaviour
    {
        private float mStartTime;
        private void Start()
        {
            mStartTime = Time.time;
        }
        private void Update()
        {
            if (Time.time - mStartTime >= 3f)
            {
                Debug.Log("Do Something");
                mStartTime = float.MaxValue;
            }
        }
    }
````

#### （2）Unity协程下的计时器

````csharp
    public class CoroutineTimerExample : MonoBehaviour
    {
        private void Start()
        {
            StartCoroutine(TimeTask(3.0f, () =>
             {
                 Debug.Log("Do Something");
             }));
        }
        IEnumerator TimeTask(float time, Action callback)
        {
            yield return new WaitForSeconds(time);
            callback?.Invoke();
        }
    }
````

#### （3）UniRx实现计时器

``Observable.Timer(TimeSpan.FromSeconds(时间)).Subscribe(_={计时任务逻辑})``

````csharp
    public class UniRxTimerExample : MonoBehaviour
    {
        private void Start()
        {
            Observable.Timer(TimeSpan.FromSeconds(3.0f))
                .Subscribe(_ =>
                {
                    Debug.Log("Do Something");
                });
        }
    }
````

### 2.独立的Update

UniRx比较初级的使用：使用UniRx注册事件以避免在Update中增加逻辑。

``Observable.EveryUpdate().Subscribe(_=>{待注册的逻辑})``

````csharp
    public class UpdateExample : MonoBehaviour
    {
        enum ButtonState
        {
            None,
            Clicked,
        }
        private void Start()
        {
            bool mouseClicked = false;
            ButtonState buttonState = ButtonState.None;
            //使用UniRx注册事件以避免在Update中增加逻辑
            Observable.EveryUpdate()
                .Subscribe(_ =>
                {
                    if (Input.GetMouseButtonDown(0))
                    {
                        Debug.Log("鼠标左键点击");
                        mouseClicked = true;
                    }
                });
            Observable.EveryUpdate()
                .Subscribe(_ =>
                {
                    if (Input.GetMouseButtonDown(1))
                    {
                        Debug.Log("鼠标右键点击");
                        mouseClicked = true;
                    }
                });
            Observable.EveryUpdate()
                .Subscribe(_ =>
                {
                    if (mouseClicked && buttonState == ButtonState.None)
                    {
                        buttonState = ButtonState.Clicked;
                        Debug.Log("按钮点击状态切换为：" + buttonState);
                    }
                });
        }
    }
````

### 3.UniRx的API：``AddTo``

**AddTo**概述：

- 一个静态扩展关键字，对接口***IDisposable***进行了扩展；
- 只要实现了此接口，都可以使用AddTo；
- 当AddTo的目标销毁的时候，就会调用***IDisposable***的``OnDispose``方法。

**AddTo**作用：

- 将GameObject或MonoBehaviour销毁与UniRx绑定。
- 当GameObjec或MonoBehaviour被销毁的时候，UniRx的相关任务也会被销毁，防止产生空引用异常，增加UniRx使用的安全性。

代码：

````csharp
            Observable.Timer(TimeSpan.FromSeconds(2f))
                .Subscribe()
                .AddTo(this);//也可以是gameObject
````

当this脚本被销毁时，Timer同时被销毁，防止空引用异常。

### 4.







![picture0](https://huskytgame.github.io/images/in-post/framework/2019-12-13-UniRx学习笔记/ScreenShot000.png)

