---
layout: article
title:  "UniRx学习笔记"
categories: framework
image:
    teaser: /in-post/framework/2019-12-13-UniRx学习笔记/DefaultImg.jpg
---

# 目录

[TOC]

## 一、概述

### 1.UniRx作用

**UniRx**：***Unity Reactive Extensions***——响应式扩展

- 简洁优雅得实现异步逻辑
- 优雅实现MVP/MVC模式
- 对UGUI/UnityAPI提供增强
- 提高编码效率

### 2.基本语法格式

``Observable.Timer().Subscribe().AddTo(继承自IDisposable接口的对象)``

其中：

- ``Observable``：可被观察的，UniRx中固定的开头
- ``Timer``：发布者，也被称作数据源/事件源
- ``Subscribe``：订阅者
- ``AddTo``：绑定销毁的生命周期

## 二、快速入门

### 1.计时器

#### （1）常规计时器

````csharp
    public class CommonTimerExample : MonoBehaviour
    {
        private float mStartTime;
        private void Start()
        {
            mStartTime = Time.time;
        }
        private void Update()
        {
            if (Time.time - mStartTime >= 3f)
            {
                Debug.Log("Do Something");
                mStartTime = float.MaxValue;
            }
        }
    }
````

#### （2）Unity协程下的计时器

````csharp
    public class CoroutineTimerExample : MonoBehaviour
    {
        private void Start()
        {
            StartCoroutine(TimeTask(3.0f, () =>
             {
                 Debug.Log("Do Something");
             }));
        }
        IEnumerator TimeTask(float time, Action callback)
        {
            yield return new WaitForSeconds(time);
            callback?.Invoke();
        }
    }
````

#### （3）UniRx实现计时器

``Observable.Timer(TimeSpan.FromSeconds(时间)).Subscribe(_={计时任务逻辑})``

````csharp
    public class UniRxTimerExample : MonoBehaviour
    {
        private void Start()
        {
            Observable.Timer(TimeSpan.FromSeconds(3.0f))
                .Subscribe(_ =>
                {
                    Debug.Log("Do Something");
                });
        }
    }
````

### 2.独立的Update

UniRx比较初级的使用：使用UniRx注册事件以避免在Update中增加逻辑。

``Observable.EveryUpdate().Subscribe(_=>{待注册的逻辑})``

````csharp
    public class UpdateExample : MonoBehaviour
    {
        enum ButtonState
        {
            None,
            Clicked,
        }
        private void Start()
        {
            bool mouseClicked = false;
            ButtonState buttonState = ButtonState.None;
            //使用UniRx注册事件以避免在Update中增加逻辑
            Observable.EveryUpdate()
                .Subscribe(_ =>
                {
                    if (Input.GetMouseButtonDown(0))
                    {
                        Debug.Log("鼠标左键点击");
                        mouseClicked = true;
                    }
                });
            Observable.EveryUpdate()
                .Subscribe(_ =>
                {
                    if (Input.GetMouseButtonDown(1))
                    {
                        Debug.Log("鼠标右键点击");
                        mouseClicked = true;
                    }
                });
            Observable.EveryUpdate()
                .Subscribe(_ =>
                {
                    if (mouseClicked && buttonState == ButtonState.None)
                    {
                        buttonState = ButtonState.Clicked;
                        Debug.Log("按钮点击状态切换为：" + buttonState);
                    }
                });
        }
    }
````

### 3.UniRx的API：``AddTo``

**AddTo**概述：

- 一个静态扩展关键字，对接口***IDisposable***进行了扩展；
- 只要实现了此接口，都可以使用AddTo；
- 当AddTo的目标销毁的时候，就会调用***IDisposable***的``OnDispose``方法。

**AddTo**作用：

- 将GameObject或MonoBehaviour销毁与UniRx绑定。
- 当GameObjec或MonoBehaviour被销毁的时候，UniRx的相关任务也会被销毁，防止产生空引用异常，增加UniRx使用的安全性。

代码：

````csharp
            Observable.Timer(TimeSpan.FromSeconds(2f))
                .Subscribe()
                .AddTo(this);//也可以是gameObject
````

当this脚本被销毁时，Timer同时被销毁，防止空引用异常。

### 4.操作符

UniRx中使用``Observable.xxxx()``会开启一条事件流（数据源/事件源），

然后使用一系列操作符对事件流进行处理、组织、整理，

最后进行订阅和生命周期绑定。

#### （1）***Where***

作用：对数据源（发布者）进行过滤；位于发布者和订阅者之间。

````csharp
    public class WhereExample : MonoBehaviour
    {
        private void Start()
        {
            Observable.EveryUpdate()
                .Where(_ => Input.GetMouseButtonDown(0))
                .Subscribe(_ =>
                {
                    Debug.Log("鼠标左键点击");
                })
                .AddTo(this);
        }
    }
````

#### （2）***First***

作用：对数据源（发布者）进行过滤；获取满足***First***内部条件的数据源中的第一个数据；可替代***Where***。

````csharp
        private void Start()
        {
            Observable.EveryUpdate()//  数据源/事件源/事件流    发布者
                .First(_ => Input.GetMouseButtonDown(0))//  处理、组织、整理
                .Subscribe(_ => Debug.Log("第一次点击鼠标左键"))//  订阅者
                .AddTo(this);//  生命周期绑定
        }
````

#### （3）***Select***

作用：映射事件流，将事件流中的事件/数据映射为其他值（类型可改变）

````csharp
//将点击按钮A的事件映射为字符串A
btnA.OnClickAsObservable().Select(_ => "A");
````

#### （4）***Merge***

作用：合并事件流

````csharp
    public class MergeExample : MonoBehaviour
    {
        private void Start()
        {
            //开启一条鼠标点击事件流
            var leftClickEventStream = Observable.EveryUpdate()
                .Where(_ => Input.GetMouseButtonDown(0));
            //开启一条新的鼠标点击事件流
            var rightClickEventStream = Observable.EveryUpdate()
                .Where(_ => Input.GetMouseButtonDown(1));
            //合并事件流
            Observable.Merge(leftClickEventStream, rightClickEventStream)
                .Subscribe(_ => Debug.Log("点击鼠标"));
        }
    }
````

#### （5）***WhenAll***

作用：监听所有事件流都执行完毕的时候

例子：监听每个按钮都点击一次：

````csharp
    //监听所有按钮点击一次
    public class AllBtnClickOneTime : MonoBehaviour
    {
        private void Start()
        {
            Button btnA = transform.Find("BtnA").GetComponent<Button>();
            Button btnB = transform.Find("BtnB").GetComponent<Button>();
            Button btnC = transform.Find("BtnC").GetComponent<Button>();

            var aStream = btnA.OnClickAsObservable().First();
            var bStream = btnB.OnClickAsObservable().First();
            var cStream = btnC.OnClickAsObservable().First();

            Observable.WhenAll(aStream, bStream, cStream)
                .Subscribe(_ => Debug.Log("按钮均点击过一次"));
        }
    }
````

### 5.对UGUI的支持

#### （1）**Button**

````csharp
            button.OnClickAsObservable()
                .First()
                .Subscribe(_ => Debug.Log("第一次点击按钮"));
````

#### （2）**Toggle**

````csharp
            toggle.OnValueChangedAsObservable()
                .Where(on => on)
                .Subscribe(_ => Debug.Log("开关为True"));
````

#### （3）**Scrollbar**

````csharp
            scrollbar.OnValueChangedAsObservable()
                .Subscribe(scrollValue =>Debug.Log("Scrolled " + scrollValue));
````

#### （4）**ScrollRect**

````csharp
            scrollRect.OnValueChangedAsObservable()
                .Subscribe(scrollValue =>Debug.Log("Scrolled " + scrollValue);
````

#### （5）**Slider**

````csharp
            slider.OnValueChangedAsObservable()
                .Subscribe(sliderValue =>Debug.Log("Slider Value " + sliderValue));
````

#### （6）**InputField**

````csharp
            mInputField.OnEndEditAsObservable()
                .Subscribe(result =>Debug.Log("Result :" + result));
````

#### （7）**Triggers——拖拽事件**

使用需导入**UniRx.Triggers**命名空间。具体API详见**ObservableTriggerExtensions.Component.cs**。

````csharp
            image.OnBeginDragAsObservable()
                .Subscribe(_ => Debug.Log("Begin Drag"));
            image.OnDragAsObservable()
                .Subscribe(_ => Debug.Log("Dragging"));
            image.OnEndDragAsObservable()
                .Subscribe(_ => Debug.Log("End Drag"));
````

#### （8）**Text**：``SubscribeToText``

````csharp
            //当 inputField 的输入值改变，则会马上显示在 resultText 上
            Text resultText = GetComponent<Text>();
            inputField.OnValueChangedAsObservable()
                .SubscribeToText(resultText);
````

#### （9）**Interactable**：``SubscribeToInteractable``

````csharp
            //IsDead为True时，设置atkBtn为不可交互
            mEnemy.IsDead.Where(isDead => isDead)
                .Select(isDead => !isDead)
                .SubscribeToInteractable(atkBtn);
````



### 6.**ReactiveProperty**——响应式属性

很多时候，当某个变量的值改变时，内部或外部需要执行相关逻辑，通常此时会将变量用属性封装，然后使用委托或事件供内部或外部注册值改变时候的逻辑。

UniRx提供ReactiveProperty响应式属性，以减少实现上述需求的代码量。

````csharp
    public class ReactivePropertyExample : MonoBehaviour
    {
        //IntReactiveProperty：可序列化的响应式属性
        public IntReactiveProperty Age = new IntReactiveProperty(25);
        private void Start()
        {
            //注册的时候，会自动执行一次内部逻辑
            Age.Subscribe(age => Debug.Log("内部订阅Age改变时候需要执行的逻辑，此时Age：" + age));
            Age.Value = 26;
            new PersonA().Init(this);
        }
    }
    public class PersonA
    {
        public void Init(ReactivePropertyExample reactivePropertyExample)
        {
            //注册的时候，会自动执行一次内部逻辑
            reactivePropertyExample.Age.Subscribe(age => Debug.Log("外部订阅Age改变时候需要执行的逻辑，此时Age：" + age));
            reactivePropertyExample.Age.Value = 27;
        }
    }
````

运行结果：

![picture0](https://huskytgame.github.io/images/in-post/framework/2019-12-13-UniRx学习笔记/ScreenShot000.png)

### 7.简单的MVP模式实现

MV(R)P模式全称：***Model—View—(Reactive)Presenter***

![picture1](https://huskytgame.github.io/images/in-post/framework/2019-12-13-UniRx学习笔记/ScreenShot001.png)



代码：

````csharp
    public class MVPExample : MonoBehaviour
    {
        EnemyModel mEnemy;
        //Unity中Hierarchy下的UI为View部分
        //Start内部为Presenter部分
        //EnemyModel为Model部分
        private void Start()
        {
            Button atkBtn = transform.Find("Button")
                .GetComponent<Button>();
            Text hpText = transform.Find("Text")
                .GetComponent<Text>();
            mEnemy = new EnemyModel(100);
            //将UI控件与Model绑定
            atkBtn.OnClickAsObservable().Subscribe(_ =>
            {
                mEnemy.Hp.Value -= 40;
            });
            mEnemy.Hp.SubscribeToText(hpText);
            mEnemy.IsDead.Where(isDead => isDead)
                .Select(isDead => !isDead)
                .SubscribeToInteractable(atkBtn);
        }
    }
    public class EnemyModel
    {
        public IntReactiveProperty Hp;
        public IReadOnlyReactiveProperty<bool> IsDead;
        public EnemyModel(int initialHp)
        {
            Hp = new IntReactiveProperty(initialHp);
            IsDead = Hp.Select(hp => hp <= 0)
                .ToReactiveProperty();
        }
    }
````

### 8.综合以上的一个小练习：点击某一个按钮后，所有按钮不再能点击，且2秒后隐藏所有按钮

````csharp
    public class EventsMaskExample : MonoBehaviour
    {
        private void Start()
        {
            Button btnA = transform.Find("ButtonA").GetComponent<Button>();
            Button btnB = transform.Find("ButtonB").GetComponent<Button>();
            Button btnC = transform.Find("ButtonC").GetComponent<Button>();

            var btnAStream = btnA.OnClickAsObservable().Select(_ => "A");
            var btnBStream = btnB.OnClickAsObservable().Select(_ => "B");
            var btnCStream = btnC.OnClickAsObservable().Select(_ => "C");

            Observable.Merge(btnAStream, btnBStream, btnCStream)
                .First()
                .Subscribe(btnCode =>
                {
                    switch (btnCode)
                    {
                        case "A":
                            Debug.Log("点击按钮A");
                            break;
                        case "B":
                            Debug.Log("点击按钮B");
                            break;
                        case "C":
                            Debug.Log("点击按钮C");
                            break;
                    }
                    Observable.Timer(TimeSpan.FromSeconds(2f))
                    .Subscribe(_ => gameObject.SetActive(false));
                });
        }
    }
````

### 9.Unity生命周期

#### （1）**EveryFixedUpdate**

````csharp
Observable.EveryFixedUpdate().Subscribe(_ => {});
````

#### （2）**EveryEndOfFrame**

````csharp
Observable.EveryEndOfFrame().Subscribe(_ => {});
````

#### （3）**EveryLateUpdate**

````csharp
Observable.EveryLateUpdate().Subscribe(_ => {});
````

#### （4）**EveryAfterUpdate**

````csharp
Observable.EveryAfterUpdate().Subscribe(_ => {});
````

#### （5）**EveryApplicationPause**

````csharp
Observable.EveryApplicationPause().Subscribe(paused => {});
````

#### （6）**EveryApplicationFocus**

````csharp
Observable.EveryApplicationFocus().Subscribe(focused => {});
````

#### （7）**EveryApplicationQuit**

````csharp
Observable.EveryApplicationQuit().Subscribe(_ => {}):
````

### 10.UniRx的Trigger

``Observable.EveryUpdate() ``这个 API 有的时候在某个脚本中实现，需要绑定 MonoBehaviour 的⽣命周期（主要是 OnDestroy），当然也有的时候是全局的，而且永远不会被销毁的。

需要绑定 MonoBehaviour 生命周期的 EveryUpdate。只需要一个 ``AddTo`` 就可以进行绑定了。

````csharp
Observable.EveryUpdate()
    .Subscribe(_ => {})
    .AddTo(this);
````

但其实有更简洁的实现:

`````csharp
this.UpdateAsObservable()
    .Subscribe(_ => {});
`````

这种类型的 Observable 是Trigger，即触发器器。

触发器，字如其意，是当某个事件发生时，则会将该事件发送到``Subscribe``函数中，而这个触发器器，本身是一个功能脚本，这个脚本挂在 GameObject 上，来监听 GameObject 的某个事件发生，事件发生则会回调给注册它的 Subscribe 中。

触发器的操作和其他的事件源 (Observable) 是一样的，都支持 Where、First、Merge 等操作符。

**Trigger**类型的 Observable 和之前所有的Observable在表现上有些不一样:

- 1.**Trigger**⼤大部分都是都是**XXXAsObsrevable**命名形式的。

- 2.在使用**Trigger**的GameObject上都会挂上对应的**Observable XXXTrigger.cs**的脚本。

  ``AddTo() ``这个 API 其实是封装了了一种 ``Trigger: ObservableDestroyTrigger``。

  **ObservableDestroyTrigger**就是当 GameObject 销毁时获取事件的一个触发器。一般的**Trigger**都会配合MonoBehaviour一起使用。
  **ObservableDestroyTrigger**的使用代码如下：

  ````csharp
  this.OnDestroyAsObservable()
      .Subscribe(_ => {});
  ````

 不同类型的Trigger：

- 1.各种细分类型的**Update**

  ``this.FixedUpdateAsObservable().Subscribe(_ => {});``

  ``this.UpdateAsObservable().Subscribe(_ => {});``

  ``this.LateUpdateAsObservable().Subscribe(_ => {});``

- 2.各种碰撞的**Trigger**

  ``this.OnCollisionEnterAsObservable(collision => {});``

  ``this.OnCollisionStayAsObservable(collision => {});``

  ``this.OnCollisionExitAsObservable(collision => {});``

- 3.一些脚本的参数监听

  ``this.OnEnableAsObservable().Subscribe(_ => {});``

  ``this.OnDisableAsObservable().Subscribe(_ => {});``

- 4.详情可以查看**ObservableTriggerExtensions.cs**和**ObervableTriggerExtensions.Component.cs**中的API。

### 11.UniRx的协程

#### （1）Unity的Coroutine与UniRx的协程

API：``.FromCoroutine()``

````csharp
    public class CoroutineExample : MonoBehaviour
    {
        private void Start()
        {
            //Unity的Coroutine：
            StartCoroutine(CoroutineA("Unity的Coroutine"));
            //UniRx的
            Observable.FromCoroutine(_ => CoroutineA("UniRx的Coroutine"))
                .Subscribe(_ => Debug.Log("协程执行完之后，再执行此处逻辑"));
        }
        IEnumerator CoroutineA(string content)
        {
            yield return new WaitForSeconds(1f);
            Debug.Log(content);
        }
    }
````

运行结果：

![picture2](https://huskytgame.github.io/images/in-post/framework/2019-12-13-UniRx学习笔记/ScreenShot002.png)

#### （2）**Observable**与**Yield对象**之间的相互转化

API：``.ToYieldInstruction()``

````csharp
    public class Observable2YieldExample : MonoBehaviour
    {
        private void Start()
        {
            StartCoroutine(CoroutineA());
        }
        IEnumerator CoroutineA()
        {
            //将Observable转化为Yield对象
            yield return Observable.Timer(TimeSpan.FromSeconds(1.0f))
                .ToYieldInstruction();
            Debug.Log("1秒后执行");
        }
    }
````

#### （3）**WhenAll**：Coroutine的并行操作

````csharp
    public class WhenAllExample : MonoBehaviour
    {
        IEnumerator A()
        {
            yield return new WaitForSeconds(1.0f);
            Debug.Log("A");
        }
        IEnumerator B()
        {
            yield return new WaitForSeconds(2.0f);
            Debug.Log("B");
        }
        private void Start()
        {
            var aStream = Observable.FromCoroutine(A);
            var bStream = Observable.FromCoroutine(B);
            //WhenAll类似于Merge操作符：用于操作事件流，监听所有事件流都执行完毕的时候
            Observable.WhenAll(aStream, bStream)
                .Subscribe(_ => Debug.Log("When All执行"));
        }
    }
````

运行结果：

![picture3](https://huskytgame.github.io/images/in-post/framework/2019-12-13-UniRx学习笔记/ScreenShot003.png)

