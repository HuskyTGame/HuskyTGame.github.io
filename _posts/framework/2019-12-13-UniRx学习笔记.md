---
layout: article
title:  "UniRx学习笔记"
categories: framework
image:
    teaser: /in-post/framework/2019-12-13-UniRx学习笔记/DefaultImg.jpg
---

# 目录

[TOC]

## 一、概述

### 1.UniRx作用

**UniRx**：***Unity Reactive Extensions***——响应式扩展

- 简洁优雅得实现异步逻辑
- 优雅实现MVP/MVC模式
- 对UGUI/UnityAPI提供增强
- 提高编码效率

### 2.基本语法格式

``Observable.Timer().Subscribe().AddTo(继承自IDisposable接口的对象)``

其中：

- ``Observable``：可被观察的，UniRx中固定的开头
- ``Timer``：发布者，也被称作数据源/事件源
- ``Subscribe``：订阅者
- ``AddTo``：绑定销毁的生命周期

## 二、快速入门

### 1.计时器

#### （1）常规计时器

````csharp
    public class CommonTimerExample : MonoBehaviour
    {
        private float mStartTime;
        private void Start()
        {
            mStartTime = Time.time;
        }
        private void Update()
        {
            if (Time.time - mStartTime >= 3f)
            {
                Debug.Log("Do Something");
                mStartTime = float.MaxValue;
            }
        }
    }
````

#### （2）Unity协程下的计时器

````csharp
    public class CoroutineTimerExample : MonoBehaviour
    {
        private void Start()
        {
            StartCoroutine(TimeTask(3.0f, () =>
             {
                 Debug.Log("Do Something");
             }));
        }
        IEnumerator TimeTask(float time, Action callback)
        {
            yield return new WaitForSeconds(time);
            callback?.Invoke();
        }
    }
````

#### （3）UniRx实现计时器

``Observable.Timer(TimeSpan.FromSeconds(时间)).Subscribe(_={计时任务逻辑})``

````csharp
    public class UniRxTimerExample : MonoBehaviour
    {
        private void Start()
        {
            Observable.Timer(TimeSpan.FromSeconds(3.0f))
                .Subscribe(_ =>
                {
                    Debug.Log("Do Something");
                });
        }
    }
````

### 2.独立的Update

UniRx比较初级的使用：使用UniRx注册事件以避免在Update中增加逻辑。

``Observable.EveryUpdate().Subscribe(_=>{待注册的逻辑})``

````csharp
    public class UpdateExample : MonoBehaviour
    {
        enum ButtonState
        {
            None,
            Clicked,
        }
        private void Start()
        {
            bool mouseClicked = false;
            ButtonState buttonState = ButtonState.None;
            //使用UniRx注册事件以避免在Update中增加逻辑
            Observable.EveryUpdate()
                .Subscribe(_ =>
                {
                    if (Input.GetMouseButtonDown(0))
                    {
                        Debug.Log("鼠标左键点击");
                        mouseClicked = true;
                    }
                });
            Observable.EveryUpdate()
                .Subscribe(_ =>
                {
                    if (Input.GetMouseButtonDown(1))
                    {
                        Debug.Log("鼠标右键点击");
                        mouseClicked = true;
                    }
                });
            Observable.EveryUpdate()
                .Subscribe(_ =>
                {
                    if (mouseClicked && buttonState == ButtonState.None)
                    {
                        buttonState = ButtonState.Clicked;
                        Debug.Log("按钮点击状态切换为：" + buttonState);
                    }
                });
        }
    }
````

### 3.UniRx的API：``AddTo``

**AddTo**概述：

- 一个静态扩展关键字，对接口***IDisposable***进行了扩展；
- 只要实现了此接口，都可以使用AddTo；
- 当AddTo的目标销毁的时候，就会调用***IDisposable***的``OnDispose``方法。

**AddTo**作用：

- 将GameObject或MonoBehaviour销毁与UniRx绑定。
- 当GameObjec或MonoBehaviour被销毁的时候，UniRx的相关任务也会被销毁，防止产生空引用异常，增加UniRx使用的安全性。

代码：

````csharp
            Observable.Timer(TimeSpan.FromSeconds(2f))
                .Subscribe()
                .AddTo(this);//也可以是gameObject
````

当this脚本被销毁时，Timer同时被销毁，防止空引用异常。

### 4.操作符

UniRx中使用``Observable.xxxx()``会开启一条事件流（数据源/事件源），

然后使用一系列操作符对事件流进行处理、组织、整理，

最后进行订阅和生命周期绑定。

#### （1）***Where***

作用：对数据源（发布者）进行过滤；位于发布者和订阅者之间。

````csharp
    public class WhereExample : MonoBehaviour
    {
        private void Start()
        {
            Observable.EveryUpdate()
                .Where(_ => Input.GetMouseButtonDown(0))
                .Subscribe(_ =>
                {
                    Debug.Log("鼠标左键点击");
                })
                .AddTo(this);
        }
    }
````

#### （2）***First***

作用：对数据源（发布者）进行过滤；获取满足***First***内部条件的数据源中的第一个数据；可替代***Where***。

````csharp
        private void Start()
        {
            Observable.EveryUpdate()//  数据源/事件源/事件流    发布者
                .First(_ => Input.GetMouseButtonDown(0))//  处理、组织、整理
                .Subscribe(_ => Debug.Log("第一次点击鼠标左键"))//  订阅者
                .AddTo(this);//  生命周期绑定
        }
````

#### （3）***Select***

作用：映射事件流，将事件流中的事件/数据映射为其他值（类型可改变）

````csharp
//将点击按钮A的事件映射为字符串A
btnA.OnClickAsObservable().Select(_ => "A");
````

#### （4）***Merge***

作用：合并事件流

````csharp
    public class MergeExample : MonoBehaviour
    {
        private void Start()
        {
            //开启一条鼠标点击事件流
            var leftClickEventStream = Observable.EveryUpdate()
                .Where(_ => Input.GetMouseButtonDown(0));
            //开启一条新的鼠标点击事件流
            var rightClickEventStream = Observable.EveryUpdate()
                .Where(_ => Input.GetMouseButtonDown(1));
            //合并事件流
            Observable.Merge(leftClickEventStream, rightClickEventStream)
                .Subscribe(_ => Debug.Log("点击鼠标"));
        }
    }
````



### 5.对UGUI的支持

#### （1）**Button**

````csharp
            button.OnClickAsObservable()
                .First()
                .Subscribe(_ => Debug.Log("第一次点击按钮"));
````

#### （2）**Toggle**

````csharp
            toggle.OnValueChangedAsObservable()
                .Where(on => on)
                .Subscribe(_ => Debug.Log("开关为True"));
````

#### （3）**Triggers——拖拽事件**

````csharp
            image.OnBeginDragAsObservable()
                .Subscribe(_ => Debug.Log("Begin Drag"));
            image.OnDragAsObservable()
                .Subscribe(_ => Debug.Log("Dragging"));
            image.OnEndDragAsObservable()
                .Subscribe(_ => Debug.Log("End Drag"));
````

### 6.**ReactiveProperty**——响应式属性

很多时候，当某个变量的值改变时，内部或外部需要执行相关逻辑，通常此时会将变量用属性封装，然后使用委托或事件供内部或外部注册值改变时候的逻辑。

UniRx提供ReactiveProperty响应式属性，以减少实现上述需求的代码量。

````csharp
    public class ReactivePropertyExample : MonoBehaviour
    {
        //IntReactiveProperty：可序列化的响应式属性
        public IntReactiveProperty Age = new IntReactiveProperty(25);
        private void Start()
        {
            //注册的时候，会自动执行一次内部逻辑
            Age.Subscribe(age => Debug.Log("内部订阅Age改变时候需要执行的逻辑，此时Age：" + age));
            Age.Value = 26;
            new PersonA().Init(this);
        }
    }
    public class PersonA
    {
        public void Init(ReactivePropertyExample reactivePropertyExample)
        {
            //注册的时候，会自动执行一次内部逻辑
            reactivePropertyExample.Age.Subscribe(age => Debug.Log("外部订阅Age改变时候需要执行的逻辑，此时Age：" + age));
            reactivePropertyExample.Age.Value = 27;
        }
    }
````

运行结果：

![picture0](https://huskytgame.github.io/images/in-post/framework/2019-12-13-UniRx学习笔记/ScreenShot000.png)

### 7.简单的MVP模式实现

MV(R)P模式全称：***Model—View—(Reactive)Presenter***

![picture1](https://huskytgame.github.io/images/in-post/framework/2019-12-13-UniRx学习笔记/ScreenShot001.png)

代码：

````csharp
    public class MVPExample : MonoBehaviour
    {
        EnemyModel mEnemy;
        //Unity中Hierarchy下的UI为View部分
        //Start内部为Presenter部分
        //EnemyModel为Model部分
        private void Start()
        {
            Button atkBtn = transform.Find("Button")
                .GetComponent<Button>();
            Text hpText = transform.Find("Text")
                .GetComponent<Text>();
            mEnemy = new EnemyModel(100);
            //将UI控件与Model绑定
            atkBtn.OnClickAsObservable().Subscribe(_ =>
            {
                mEnemy.Hp.Value -= 40;
            });
            mEnemy.Hp.SubscribeToText(hpText);
            mEnemy.IsDead.Where(isDead => isDead)
                .Select(isDead => !isDead)
                .SubscribeToInteractable(atkBtn);
        }
    }
    public class EnemyModel
    {
        public IntReactiveProperty Hp;
        public IReadOnlyReactiveProperty<bool> IsDead;
        public EnemyModel(int initialHp)
        {
            Hp = new IntReactiveProperty(initialHp);
            IsDead = Hp.Select(hp => hp <= 0)
                .ToReactiveProperty();
        }
    }
````

### 8.综合以上的一个小练习：点击某一个按钮后，所有按钮不再能点击，且2秒后隐藏所有按钮

````csharp
    public class EventsMaskExample : MonoBehaviour
    {
        private void Start()
        {
            Button btnA = transform.Find("ButtonA").GetComponent<Button>();
            Button btnB = transform.Find("ButtonB").GetComponent<Button>();
            Button btnC = transform.Find("ButtonC").GetComponent<Button>();

            var btnAStream = btnA.OnClickAsObservable().Select(_ => "A");
            var btnBStream = btnB.OnClickAsObservable().Select(_ => "B");
            var btnCStream = btnC.OnClickAsObservable().Select(_ => "C");

            Observable.Merge(btnAStream, btnBStream, btnCStream)
                .First()
                .Subscribe(btnCode =>
                {
                    switch (btnCode)
                    {
                        case "A":
                            Debug.Log("点击按钮A");
                            break;
                        case "B":
                            Debug.Log("点击按钮B");
                            break;
                        case "C":
                            Debug.Log("点击按钮C");
                            break;
                    }
                    Observable.Timer(TimeSpan.FromSeconds(2f))
                    .Subscribe(_ => gameObject.SetActive(false));
                });
        }
    }
````













